{"./":{"url":"./","title":"前言.写给有缘人","keywords":"","body":"前言·写给有缘人 常看看 但行好事，莫问前程 临渊羡鱼，不如退而结网 我本微末凡尘，可也心向天空 不要去追马，用追马的时间去种草 如果我不曾见过光明，那么我将无惧黑暗 种一棵树最好的时间是十年前，而后是现在 "},"gitbook/0.0.0.html":{"url":"gitbook/0.0.0.html","title":"零.0.0 从零开始使用 gitbook 搭建文档站点","keywords":"","body":"从零开始使用gitbook搭建文档站点 安装gitbook-cli脚手架工具 npm i -g gitbook-cli 查看安装版本 gitbook --version gitbook -V 初始化项目 // 执行如下命令会在当前目录下生成2个文件（README.md && SUMMARY.md） gitbook init // 执行如下命令会在当前的note文件夹下生产2个文件（README.md && SUMMARY.md） // 如果没有note文件夹，会先创建note文件夹 git init ./note 注意1：执行gitbook init命令如果报如下错误： Installing GitBook 3.2.3 SOLINK_MODULE(target) Release/.node CXX(target) Release/obj.target/fse/fsevents.o SOLINK_MODULE(target) Release/fse.node SOLINK_MODULE(target) Release/.node CXX(target) Release/obj.target/fse/fsevents.o SOLINK_MODULE(target) Release/fse.node /usr/local/lib/node_modules/gitbook-cli/node_modules/npm/node_modules/graceful-fs/polyfills.js:287 if (cb) cb.apply(this, arguments) ^ TypeError: cb.apply is not a function at /usr/local/lib/node_modules/gitbook-cli/node_modules/npm/node_modules/graceful-fs/polyfills.js:287:18 at FSReqCallback.oncomplete (fs.js:184:5) 关键信息 TypeError: cb.apply is not a function at /usr/local/lib/node_modules/gitbook-cli/node_modules/npm/node_modules/graceful-fs/polyfills.js:287:18 解决方法：修改polyfills.js文件内容，注释一下三行内容（62行左右） // fs.stat = statFix(fs.stat) // fs.fstat = statFix(fs.fstat) // fs.lstat = statFix(fs.lstat) 注意2：执行gitbook init命令如果报如下错误： 原因：node版本太高，进行降级处理或者不处理此报错，手动创建SUMMARY.md文件 warn: no summary file in this book info: create README.md info: create SUMMARY.md TypeError [ERR_INVALID_ARG_TYPE]: The \"data\" argument must be of type string or an instance of Buffer, TypedArray, or DataView. Received an instance of Promise 启动项目（本地服务器） gitbook serve 打包项目 gitbook build SUMMARY.md书写格式如下 # Summary * [前言.写给有缘人](README.md) ### 零、GITBOOK * [零.0.0 从零开始使用gitbook搭建文档站点](0/0.0.0.md) * [零.0.1 gitbook插件集合](0/0.0.1.md) ### 佰、ROLLUP * [佰.0.0 rollup介绍](100/100.0.0.md) * [佰.0.1 rollup基础](100/100.0.1.md) gitbook之配置文件book.json // root：配置README.md && SUMMARY.md的位置 { \"root\": \"./docs\", \"title\": \"codeing\", \"description\": \"codeing...\", \"language\": \"zh-hans\", \"@styles\": { \"website\": \"./styles/website.css\" }, \"@links\": { \"sidebar\": { \"知乎\": \"https://www.zhihu.com/people/codeing.cn\", \"gitbook\": \"https://zhuanlan.zhihu.com/p/34946169\", \"前端内参\": \"https://coffe1891.gitbook.io\", \"如何学习\": \"https://juejin.cn/post/6960892566921281543\" } }, \"plugins\": [ \"-search\", \"search-pro\" ] } "},"gitbook/0.0.1.html":{"url":"gitbook/0.0.1.html","title":"零.0.1 gitbook 插件集合","keywords":"","body":"GITBOOK插件集合 介绍一下gitbook中book.json的一些实用配置和插件 全局配置 title 设置本书的标题（书名） \"title\": \"前端系列文章\" author 本书的作者的相关信息 \"author\": \"codeing.cn\" description 本书的简单描述 \"description\": \"记录与分享前端相关技术系列文章\" language 配置本书使用的语言 // 配置使用简体中文 \"language\": \"zh-hans\" links 配置在左侧导航栏的链接 \"links\": { \"sidebar\": { \"Home\": \"https://www.zhihu.com/people/codeing.cn\" } } styles 自定义页面样式，默认情况下各generator对应的css文件如下 \"styles\": { \"website\": \"styles/website.css\", \"ebook\": \"styles/ebook.css\", \"pdf\": \"styles/pdf.css\", \"mobi\": \"styles/mobi.css\", \"epub\": \"styles/epub.css\" } 例如使 标签有下边框， 可以在website.css中设置 h1 , h2{ border-bottom: 1px solid #EFEAEA; } 插件相关 plugins 配置使用的插件 \"plugins\": [ \"-search\", \"back-to-top-button\", \"expandable-chapters-small\", \"insert-logo\" ] 其中\"-search\"中的 - 符号代表去除默认自带的插件 // Gitbook默认自带有5个插件: highlight // 代码高亮 search // 导航栏查询功能（不支持中文） sharing // 右上角分享功能 font-settings // 字体设置（最上方的\"A\"符号） livereload // 为GitBook实时重新加载 pluginsConfig 配置插件的属性 // 配置insert-logo的属性 \"pluginsConfig\": { \"insert-logo\": { \"url\": \"images/logo.png\", \"style\": \"background: none; max-height: 30px; min-height: 30px\" } } "},"vscode/0.0.0.html":{"url":"vscode/0.0.0.html","title":"零.0.0 前端必装插件","keywords":"","body":"vscdeo的使用 1，配置环境变量 // 把安装目录或者安装目录的子目录bin目录添加到环境变量即可 2，前端必装插件 chinese language pack for ... debugger for chrome auto close tag auto rename tag live server // 启动本地服务 open in browser git graph // git commit 记录查看 power mode // 编码光标显示特效 svg preview // svg预览 prettier - code formatter vetur // vue2开发必装 volar // vue3开发必装 vscode-icons // vscode文件&文件夹图标 eslint 3，vscode 用户设置 // 保存文件时自动format格式化 \"editor.formatOnSave\": true, // 默认格式化工具，pritter \"editor.defaultFormatter\": \"esbenp.prettier-vscode\", // 终端默认打开为git bash \"terminal.integrated.defaultProfile.windows\": \"Git Bash\", "},"css/0.0.0.html":{"url":"css/0.0.0.html","title":"贰.0.0 css reset","keywords":"","body":"reset.scss && common.scss && global.scss reset.scss reset css common.scss 1，padding && margin @for $i from 1 through 6 { // padding .p-#{$i*5} { padding: #{$i * 5}px; } // padding-left .pl-#{$i*5} { padding-left: #{$i * 5}px; } // padding-right .pr-#{$i*5} { padding-right: #{$i * 5}px; } // padding-top .pt-#{$i*5} { padding-top: #{$i * 5}px; } // padding-bottom .pb-#{$i*5} { padding-bottom: #{$i * 5}px; } // 水平方向 .px-#{$i*5} { padding-left: #{$i * 5}px; padding-right: #{$i * 5}px; } // 垂直方向 .py-#{$i*5} { padding-top: #{$i * 5}px; padding-bottom: #{$i * 5}px; } // margin .m-#{$i*5} { margin: #{$i * 5}px; } // margin-left .ml-#{$i*5} { margin-left: #{$i * 5}px; } // margin-right .mr-#{$i*5} { margin-right: #{$i * 5}px; } // margin-top .mt-#{$i*5} { margin-top: #{$i * 5}px; } // margin-bottom .mb-#{$i*5} { margin-bottom: #{$i * 5}px; } // 水平方向 .mx-#{$i*5} { margin-left: #{$i * 5}px; margin-right: #{$i * 5}px; } // 垂直方向 .my-#{$i*5} { margin-top: #{$i * 5}px; margin-bottom: #{$i * 5}px; } } 2，flex布局 .d-flex{ display: flex; } .flex-col { flex-direction: column; } .jc-center { justify-content: center; } .jc-around { justify-content: space-around; } .jc-between { justify-content: space-between; } .ai-center { align-items: center; } .flex-1 { flex: 1; overflow: auto; } .center { display: flex; align-items: center; justify-content: center; } .flex-wrap{ flex-wrap: wrap; } global.scss 根据不同的项目不同 1，主题色 $them-color: pink; "},"git/0.0.0.html":{"url":"git/0.0.0.html","title":"叁.0.0 基本用法","keywords":"","body":"基本用法 配置 // 设置用户名和邮箱 git config --global user.email \"you@example.com\" git config --global user.name \"Your Name\" // 查看全局配置 git config --global --list git stash // 保存状态 git stash // 查看 git stash list // 恢复 // pop状态恢复并删除记录，apply状态恢复，drop删除记录 git stash pop || git stash apply && git stash drop 分支 // git pull 确保本地分支是新的 // 查看本地分支 git branch // 查看远程分支 git branch -r // 查看所有分支 git branch -a // 新建本地分支：dev git branch dev // 切换到本地dev分支 git checkout dev // 新建本地分支issue-001并切换到issue-001分支 git checkout -b issue-001 // 新建本地分支并追踪远端分支：根据远程分支新建本地分支 && 建立关联关系 git checkout -b release/release1.15.1 origin/release/release1.15.1 // 新建本地分支，并切换到新建的本地分支，拉取对应远程分支内容，并追踪远程分支（与远程分支关联） // 方式一 git branch branchName // 新建与远程分支相对应的分支 git checkout branchName // 切换到新建分支 git pull origin branchName // 更新新分支数据，与远程进行同步 // -u 是 --set-upstream 的简写形式，本地分支与远程分支关联 git push -u origin branchName || git push --set-upstream origin feature // 方式二 git branch branchName git checkout branchName git pull origin branchName // 更新新分支数据，与远程分支进行同步 // 本地分支与远程分支关联 git branch --set-upstream-to=origin/branchName branchName // 关联后以后直接 git push 就可以了 git push // 新建远程分支的二种方式 // 方式一：直接在github或者gitee等代码托管平台新建分支 // 方式二：把本地当前分支push到远程分支 git push origin // 删除本地分支 git branch -d branchName git branch -D branchName // 强制删除 // 删除远程分支 git push origin --delete branchName git log查看日志 git reflog查看commits push后撤销push操作 // 先在本地回退到相应的版本： git reset --hard // 注意使用 --hard 参数会抛弃当前工作区的修改 // 使用 --soft 参数的话会回退到之前的版本，但是保留当前工作区的修改，可以重新提交 // 如果此时使用命令： git push origin // 会提示本地的版本落后于远端的版本； // 为了覆盖掉远端的版本信息，使远端的仓库也回退到相应的版本，需要加上参数--force git push origin --force 撤销工作空间（还没 git add）的更改 // 撤销单个或多个 git restore ... // 撤销全部 git restore . 撤销暂存（已经 git add）的更改 git restore --staged ... git restore --staged . "},"git/0.0.1.html":{"url":"git/0.0.1.html","title":"叁.0.1 回退版本：本地 && 远程","keywords":"","body":"回退版本：本地 && 远程 // 本地回退到指定commit_id git reset --hard 30e889e79b8 // 远程同步 git push origin release/1.23.1 --force "},"git/0.0.2.html":{"url":"git/0.0.2.html","title":"叁.0.2 打标签","keywords":"","body":"打标签 // 本地新增有备注的tag（默认在当前分支最后一个commit上添加tag） git tag -a v1.1.1 -m \"测试\" // git tag -a 标签名 -m “备注内容” // 将tag推送到远程分支 git push origin v1.1.0 // git push origin 标签名 // 查询本地所有tag git tag // 本地新增无备注的tag（默认在当前分支最后一个commit上添加tag） git tag v1.1.0 // git tag 标签名 // 本地新增有备注的tag（默认在当前分支最后一个commit上添加tag） git tag -a v1.1.1 -m \"测试\" // git tag -a 标签名 -m “备注内容” // 在指定commit上新增tag // git tag 标签名 commit（前几位也可以，尝试过最低3位报错，最好5位以上） git tag v1.1.0 105851905c8a0f9cc040cf845b35c1ced1963fcc // 将tag推送到远程分支 git push origin v1.1.0 // git push origin 标签名 // 删除本地分支标签 git tag -d v1.1.0 // git tag -d 标签名 // 删除远程分支标签 git push origin :refs/tags/v1.1.0 // git push origin :refs/tags/标签名 "},"git/0.0.3.html":{"url":"git/0.0.3.html","title":"叁.0.3 删除缓存的远程分支列表","keywords":"","body":"删除缓存的远程分支列表 git remote prune origin "},"webpack/0.0.0.html":{"url":"webpack/0.0.0.html","title":"肆.0.0 webpack 基础","keywords":"","body":"webpack 基础 const path = require(\"path\"); module.exports = { mode: \"production\", // 打包入口 entry: { app: \"./src/index.js\", }, // 输出路径及文件名 output: { path: path.resolve(__dirname, \"../dist\"), filename: \"[name].[hash:5].js\", }, resolve: { // 设置路径别名 alias: { \"@\": path.resolve(__dirname, \"../src\"), }, }, }; "},"webpack/0.0.1.html":{"url":"webpack/0.0.1.html","title":"肆.0.1 clean-webpack-plugin","keywords":"","body":"clean-webpack-plugin 安装clean-webpack-plugin npm i -D clean-webpack-plugin 使用clean-webpack-plugin const { CleanWebpackPlugin } = require('clean-webpack-plugin'); module.exports = { plugins: [ new CleanWebpackPlugin(), ], }; "},"webpack/0.0.2.html":{"url":"webpack/0.0.2.html","title":"肆.0.2 html-webpack-plugin","keywords":"","body":"html-webpack-plugin 安装html-webpack-plugin npm i -D html-webpack-plugin 使用html-webpack-plugin const HtmlWebpackPlugin = require(\"html-webpack-plugin\"); module.exports = { plugins: [ // 创建实例 new HtmlWebpackPlugin({ // 标题 title: \"我是标题\", // 生产的文件名 filename: \"index.html\", // 文件模板 template: path.resolve(__dirname, \"../index.html\"), }), ], }; 模板文件中使用标题 "},"webpack/0.0.3.html":{"url":"webpack/0.0.3.html","title":"肆.0.3 webpack-dev-server","keywords":"","body":"webpack-dev-server 安装webpack-dev-server npm i -D webpack-dev-server 使用webpack-dev-server module.exports = { devServer: { // 主机地址 host: \"127.0.0.1\", // 端口号 port: 3100, open: true, hot: true, // 跨域设置代理 proxy: { \"/api\": { target: \"https://xxxx.com/api/\", changeOrigin: true, pathRewrite: { \"^/api\": \"/\" }, }, }, // 是否开启gzip压缩 compress: true, }, }; "},"webpack/0.0.4.html":{"url":"webpack/0.0.4.html","title":"肆.0.4 module-rules","keywords":"","body":"module-rules "},"webpack/0.0.5.html":{"url":"webpack/0.0.5.html","title":"肆.0.5 source-map","keywords":"","body":"source-map "},"uniapp/0.0.0.html":{"url":"uniapp/0.0.0.html","title":"伍.0.0 vite.config.js","keywords":"","body":"配置如下 import { defineConfig } from \"vite\"; import uni from \"@dcloudio/vite-plugin-uni\"; // https://vitejs.dev/config/ export default defineConfig({ base: './', // 这个是打包的静态资源基础路径 plugins: [uni()], css: { // 这个是全局样式先执行 preprocessorOptions: { scss: { additionalData: `@import 'src/scss/index.scss';` } } } }); "},"typescript/0.0.0.html":{"url":"typescript/0.0.0.html","title":"陆.0.0 注意点","keywords":"","body":"手册指南-接口：https://www.tslang.cn/docs/handbook/interfaces.html 菜鸟教程：https://www.runoob.com/typescript/ts-namespace.html 对象字面量 【对象字面量】会被特殊对待而且会经过 额外属性检查，当将它们【赋值给变量】或【作为参数传递】的时候。如果一个对象字面量存在任何“目标类型”不包含的属性时，你会得到一个错误。 解决方案有三: 1, 最low：直接把对象字面量赋值给一个变量，这个变量不声明类型，然后把变量【赋值给变量】或【作为参数传递】 2, 也low：把字面量对象包装下，比如使用Object.create({})，或new Object({}) 2，最简便：使用类型断言 3，最佳：添加一个字符串【索引签名】 命名空间之-///用法 如果一个命名空间在一个单独的 TypeScript 文件中，则应使用三斜杠 /// 引用它，语法格式如下： 文档地址：https://www.runoob.com/typescript/ts-namespace.html /// vue3+vite+ts中用到了这个知识点 yarn create vite myapp --template vue-ts 配置文件：tsconfig.json tsc --init // 上面命令会生成tsconfig.json文件，包含所有可配置项 "},"electron/0.0.0.html":{"url":"electron/0.0.0.html","title":"柒.0.0 Electron入门","keywords":"","body":"Electron入门 打开调试窗口 win.webContents.openDevTools() 关闭调试窗口 win.webContents.closeDevTools() 去除顶部菜单 const { Menu } = require('electron') Menu.setApplicationMenu(null) 自定义顶部菜单 //引入Menu模块 const { Menu } = require('electron') let menu = Menu.buildFromTemplate(template); Menu.setApplicationMenu(menu); //Menu.setApplicationMenu(null); //这个是不显示菜单栏的效果 打开全屏模式 win.setFullScreen(true) 退出全屏模式 win.setFullScreen(false) 注册快捷键 // ctrl+q:退出全屏 globalShortcut.register('ctrl+q', ()=>{ win.setFullScreen(false) }) dialog：打开从电脑选择文件的对话框 通知 主进程触发（相当于nodejs触发） ```javascript const { Notification } = require('electron') new Notification({ title: '标题', body: '内容' }).show() - 渲染进程触发（相当于浏览器触发，使用：H5 Notification API） ```javascript // 触发通知 const notifyObj = new Notification('提示', { body: '提示信息...' }) notifyObj.onclick = ()=>{ // 下面打印信息输出到控制台界面 console.log('hello') } 自定义右键菜单 Menu && MenuItem 系统托盘：Tray // 展示再任务栏右侧的小图标 const { app, Menu, Tray } = require('electron') let tray = null app.whenReady().then(() => { tray = new Tray('/path/to/my/icon') const contextMenu = Menu.buildFromTemplate([ { label: 'Item1', type: 'radio' }, { label: 'Item2', type: 'radio' }, { label: 'Item3', type: 'radio', checked: true }, { label: 'Item4', type: 'radio' } ]) // 鼠标移动到图表上展示提示 tray.setToolTip('This is my application.') // tray.setContextMenu(contextMenu) // 左键点击，展示窗口 tray.on('click', (e,bounds)=>{ win.show() }) }) 进程之间通信 sned&on：渲染进程到主进程 sendTo&on：渲染进程到渲染进程 invoke&handle：渲染进程到主进程 invoke执行后返回promise，因此invoke().then() mainWindow.webCOntents.send('message', 'haha')：主进程到渲染进程 // sned&on ipcRenderer.send('evnet_name', 'event_message') ipcMain.on('event_name', (event,data)=>{ console.log('接收到的数据是' + data) e.sender.send('reply', 'reply_message') || e.reply('reply', 'reply_message') }) ipcRenderer.on('reply', (event,data)=>{ console.log('接收到的数据是' + data) }) // sendTo&on ipcRenderer.send('evnet_name', 'event_message') ipcRenderer.on('evnet_name', (event,data)=>{ console.log('接收到的数据是' + data) }) // invoke&handle ipcMain.handle('event_name', (event,data)=>{ return data }) ipcRenderer.invoke('evnet_name', 'event_message') .then(res=>{ cosnole.log('res',res) }) "},"electron/0.0.1.html":{"url":"electron/0.0.1.html","title":"柒.0.1 Electron打包","keywords":"","body":"打包 文档：https://www.electronjs.org/zh/docs/latest/tutorial/quick-start#%E6%89%93%E5%8C%85%E5%B9%B6%E5%88%86%E5%8F%91%E6%82%A8%E7%9A%84%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F 方式一：electron-forge yarn add --dev @electron-forge/cli npx electron-forge make 方式二：electron-builder yarn add -D electron-builder npx electron-builder // 如果报错get http://xxxxxx.zip，手动下载4个文件并放到对应的目录 // 1，下载 electron-v*.*.*-win32-x64.zip压缩包，无需解压直接放到 C:\\Users\\Admin\\AppData\\Local\\electron\\Cache\\目录下 // 2，下载 winCodeSign-2.6.0压缩包，解压后放到 C:\\Users\\Admin\\AppData\\Local\\electron-builder\\Cache\\winCodeSign\\目录下 // 3，下载 nsis-3.0.4.1压缩包，解压后放到 C:\\Users\\Admin\\AppData\\Local\\electron-builder\\Cache\\nsis\\目录下 // 4，下载 nsis-resources-3.4.1压缩包，解压后放到 C:\\Users\\Admin\\AppData\\Local\\electron-builder\\Cache\\nsis\\目录下 打包相关配置：package.json \"build\": { // 这里是electron-builder的配置 \"productName\":\"xxxx\",//项目名 这也是生成的exe文件的前缀名 \"appId\": \"com.xxx.xxxxx\",//包名 \"copyright\":\"xxxx\",//版权 信息 \"directories\": { // 输出文件夹 \"output\": \"build\" }, // windows相关的配置 \"win\": { \"icon\": \"xxx/icon.ico\",//图标路径 \"target\": [ { \"target\": \"nsis\" // 我们要的目标安装包 } ] } } "},"electron/0.0.2.html":{"url":"electron/0.0.2.html","title":"柒.0.2 Electron加密","keywords":"","body":"源码加密 参考文档：https://zhuanlan.zhihu.com/p/84386456 Electron源代码的终极加密保护⽅案——使⽤bytenode（包括不兼容错误的处理技巧） 开发的东西⽐较多，但是很少写博客，除⾮遇到对⾃⼰帮助极⼤的经验技巧，就分享给⼤家，避免⾛弯路和陷⼊绝望,今天分享的是Electron项⽬源码在⽬前最佳的保护⽅案，传统的加密打包和混淆，毕竟是治标不治本，正如官⽅⼀群⼈讨论的那样，认为⽆论怎么打包，密钥还是在包⾥，所以根本办法还是要⽣成字节码，像其他硬编码语⾔那样，把破解的可能性只留给⼀⼩撮⾼⼿，⽽不是⼀个解包命令就能搞定。 提到node⽣成字节码，许多⼈都会介绍v8提供的虚拟机模块做编译和加载，类似这个样⼦： let fs = require('fs'); let vm = require('vm'); // 生成字节码 function gen_bytes(src_file,dst_file) { let data = fs.readFileSync(src_file); const script = new vm.Script(data, { produceCachedData: true }); const bytes = script.cachedData; fs.writeFileSync(dst_file,bytes); } // 运行字节码 function run_bytes(bin_file) { let code = fs.readFileSync(bin_file); const length = code.slice(8, 12).reduce(function (sum, number, power) { return sum += number * Math.pow(256, power); }); const anotherScript = new vm.Script(' '.repeat(length), { cachedData: code }); anotherScript.runInThisContext(code); } gen_bytes('demo.js','demo'); run_bytes('demo'); ⽣成字节码 require('bytenode').compileFile({ filename: 'my_module.js' //它会在源⽂件同⼀⽬录下⽣成同名jsc后缀的字节码⽂件 }); 加载字节码⽂件 require('bytenode');//在引⼊字节码⽂件前先引⼊bytenode let my_module = require('my_module.jsc');//引⼊jsc⽂件和加载普通模块⽆异，⾮常⽅便 //...开始愉快的使⽤my_module中的功能吧 但是在electron⾥使⽤时，⼤家⼤概率可能会在控制台遇到这样的报错“Invalid or incompatible cached data ...”，这个原因是你⽤bytecode编译js⽂件时使⽤的node环境和electron集成的node环境不兼容，我从苦于eletron没有好的加密措施到找到bytecode神器再到遇到这个问题，是从绝望到兴奋⼜到⼼灰意冷，外⽹上也看到⼀个⼈问类似的问题，但没⼈回答，幸运的是，我急中⽣智，我想既然在系统node环境⾥编译⽣成的不能⽤，下载⼀个和electron-node环境⼀致的node重装⼜⿇烦，⽽且也不知道⾏不⾏（因为外⽹那个⼈就是说他编译⽤的node环境和electron-node版本是⼀致的，这让我没了重装node尝试的欲望），于是我打开electron的调试窗⼝，在控制台输⼊bytecode编译指令，再次⽣成了⼀个jsc⽂件，重新加载，⼀切OK，超级开⼼，遂记录下来分享给⼤家。 bytenode用法 用法一：命令行 // 编译单个文件 bytenode -c file.js // 编译多个文件 bytenode -c file1.js file2.js file3.js ... // 编译src目录下的js文件 bytenode -c src/*.js // 编译src目录的所有直接子目录下的所有js文件 bytenode -c src/**/*.js 用法二：api ```javascript // 引入bytenode const bytenode = require('bytenode') // 编译js代码为字节码 let byteCodeRes = bytenode.compileCode('console.log(999)') // 运行js代码编译后的字节码 bytenode.runBytecode(byteCodeRes); // 编译js文件 let compiledFilename = bytenode.compileFile({ filename: '/path/to/your/file.js', output: '/path/to/compiled/file.jsc' // if omitted, it defaults to '/path/to/your/file.jsc' }); ``` "},"electron/0.0.3.html":{"url":"electron/0.0.3.html","title":"柒.0.3 Electron常见问题","keywords":"","body":"常见问题 安装： // 安装慢的问题，参考官网：https://www.electronjs.org/docs/latest/tutorial/installation // 原理：自定义镜像和缓存 npm config set ELECTRON_MIRROR=\"https://npmmirror.com/mirrors/electron/\" or npm config set ELECTRON_MIRROR https://npm.taobao.org/mirrors/electron/ // 为什么安装这么慢：从源码解析Electron的安装为什么这么慢 https://zhuanlan.zhihu.com/p/349123186 "},"electron/0.0.4.html":{"url":"electron/0.0.4.html","title":"柒.0.4 Electron项目搭建","keywords":"","body":"项目搭建 项目创建 yarn create vite myapp --template vue cd myapp yarn // yarn dev 安装electron相关依赖 // 必装 yarn add -D electron electron-builder cross-env concurrently // 可选 // yarn add -D wait-on @types/electron 配置入口文件&description&author // package.json \"description\": \"myapp\", \"author\": \"coffee1949\", \"main\": \"main.js\", 创建入口文件main.js // main.js const { app, BrowserWindow } = require('electron') let mainWindow function createWindow(){ mainWindow = new BrowserWindow({ width: 800, height: 600, webPreferences: { nodeIntegration: true, contextIsolation: false } }) mainWindow.loadURL('http://localhost:3000') } app.whenReady().then(()=>{ createWindow() }) 配置scripts // package.json \"scripts\": { \"dev\": \"concurrently -k vite \\\"cross-env NODE_ENV=development electron .\\\"\", \"build\": \"vite build && electron-builder\" }, 启动项目 yarn dev 启动会闪以下，优化main.js const { app, BrowserWindow } = require('electron') let mainWindow function createWindow(){ mainWindow = new BrowserWindow({ width: 800, height: 600, show: false, // 默认隐藏 webPreferences: { nodeIntegration: true, contextIsolation: false } }) mainWindow.once('ready-to-show', ()=>{ mainWindow.show() // 窗口准备完毕，显示窗口 }) mainWindow.loadURL('http://localhost:3000') } app.whenReady().then(()=>{ createWindow() }) 集成vue-router 1，安装 yarn add vue-router 2，创建3个页面视图，如下： // 1，src/pages/home/index.vue import { ref } from 'vue' const msg = ref('home') // 2，src/pages/list/index.vue import { ref } from 'vue' const msg = ref('list') // 3，src/pages/info/index.vue import { ref } from 'vue' const msg = ref('info') 3，创建 src/router/router.ts文件，内容如下 import { createRouter, createWebHistory } from 'vue-router' const routes = [ { path: '/', name: 'home', component: ()=>import('@/pages/home/index.vue') }, { path: '/list', name: 'list', component: ()=>import('@/pages/list/index.vue') }, { path: '/info', name: 'info', component: ()=>import('@/pages/info/index.vue') }, ] const router = createRouter({ history: createWebHistory(), routes }) export default router 3，在 main.ts文件中引入 router.js文件，main.ts内容如下： import { createApp } from 'vue' import router from '@/router/router' import App from '@/App.vue' createApp(App).use(router).mount('#app') 4，配置@-src映射 在vite.config.js配置文件中增加resolve.alias配置，如下 import { defineConfig } from \"vite\"; import vue from \"@vitejs/plugin-vue\"; export default defineConfig({ plugins: [vue()], // 增加resolve.alias配置 resolve: { alias: { \"@\": \"/src\", }, }, }); 5，修改app.vue文件内容 home list info 打包：yarn build 1，窗口加载的url是本地开发的前端服务，需要根据环境判断 const url = process.env.NODE_ENV === 'development' ? 'http://localhost:3000' : `file://${__dirname}/dist/index.html` mainWindow.loadURL(url) 2，打包测试，报错找不到html，配置package.json的build的files // 进入到win-unpacked/resources目录，解包看下路径是否正确 // 全局安装asar npm i -g asar // 解包 asar extract app.asar app // 查看路径正确否 // 配置package.json的build参数 \"build\": { \"productName\": \"coffee\", \"appId\": \"com.coffee.app\", \"copyright\": \"copyright @ coffee\", \"directories\": { \"output\": \"out\" }, \"files\": [ // 这里重要 \"./dist/**/*\", \"./main.js\" ] } 3，之后报错：GET file:///C:/src/main.js net::ERR_FILE_NOT_FOUND // 配置vite.config.js的base参数 import { defineConfig } from 'vite' import vue from '@vitejs/plugin-vue' export default defineConfig({ plugins: [vue()], base: './', // 这里 resolve: { alias: { \"@\": \"/src\", }, }, }) "},"glob/0.0.0.html":{"url":"glob/0.0.0.html","title":"拾.0.0 前端工程化~强大的glob语法","keywords":"","body":"前端工程化~强大的glob语法 glob 在正则出现之前就有了，主要用于匹配文件路径，例如大名鼎鼎的 gulp 就使用了 glob 规则来匹配、查找并处理各种后缀的文件。在前端工程化的过程中，不可避免地会用 Node.js 来读取文件，例如想找到 src 目录下所有 js 和 jsx 文件，代码应该怎么写呢？首先安装依赖包： yarn add glob 然后 3 行代码搞定： const glob = require('glob') const files = glob.sync('src/**/*.js{,x}') console.log(files) 有没有感觉很强大呢？更重要的是 glob 语法在命令行就支持，不需要安装任何依赖，例如老板让你创建 a1.js 到 a9.js、b1.js 到 b9.js 这 18 个测试文件的话，怎么操作？一个个创建的话太傻了，glob 一句话就搞定： $ touch {a,b}{1..9}.js $ ls a1.js a3.js a5.js a7.js a9.js b2.js b4.js b6.js b8.js a2.js a4.js a6.js a8.js b1.js b3.js b5.js b7.js b9.js 更更更重要的是，glob 的语法非常简单，只要记住下面7个符号代表的含义就能掌握了： 基础语法：/、*、?、[] 拓展语法：**、{}、() 接下来就逐个解释一下： 基础语法 分隔符和片段 概念：分隔符是/，通过split('/') 得到的数组每一项是片段。 示例： src/index.js 有两个片段，分别是 src 和 index.js src/**/*.js 有三个片段，分别是 src、** 和 *.js 单个星号 概念：单个星号 * 用于匹配单个片段中的零个或多个字符。 示例： src/*.js 表示 src 目录下所有以 js 结尾的文件，但是不能匹配 src 子目录中的文件，例如 src/login/login.js /home/*/.bashrc 匹配所有用户的 .bashrc 文件 需要注意的是，* 不能匹配分隔符/，也就是说不能跨片段匹配字符。 问号 概念：问号 ? 匹配单个片段中的单个字符。 示例： test/?at.js 匹配形如 test/cat.js、test/bat.js 等所有3个字符且后两位是 at 的 js 文件，但是不能匹配 test/flat.js src/index.?? 匹配 src 目录下以 index 打头，后缀名是两个字符的文件，例如可以匹配 src/index.js 和 src/index.md，但不能匹配 src/index.jsx 中括号 概念: 同样是匹配单个片段中的单个字符，但是字符集只能从括号内选择，如果字符集内有-，表示范围。 示例： test/[bc]at.js 只能匹配 test/bat.js 和 test/cat.js test/[c-f]at.js 能匹配 test/cat.js、test/dat.js、test/eat.js 和 test/fat.js 惊叹号 概念：表示取反，即排除那些去掉惊叹号之后能够匹配到的文件。 示例： test/[!bc]at.js不能匹配 test/bat.js 和 test/cat.js，但是可以匹配 test/fat.js !test/tmp/** 排除 test/tmp 目录下的所有目录和文件 扩展语法 基础语法非常简单好记，但是功能非常局限，为了丰富 glob 的功能，衍生了下面三种扩展语法： 两个星号 概念：两个星号 ** 可以跨片段匹配零个或多个字符，也就是说**是递归匹配所有文件和目录的，如果后面有分隔符，即 **/ 的话，则表示只递归匹配所有目录（不含隐藏目录）。 示例： /var/log/** 匹配 /var/log 目录下所有文件和文件夹，以及文件夹里面所有子文件和子文件夹 /var/log/**/*.log 匹配 /var/log 及其子目录下的所有以 .log 结尾的文件 /home/*/.ssh/**/*.key 匹配所有用户的 .ssh 目录及其子目录内的以 .key 结尾的文件 大括号 概念：匹配大括号内的所有模式，模式之间用逗号进行分隔，支持大括号嵌套，支持用 .. 匹配连续的字符，即 {start..end} 语法。 示例： a.{png,jp{,e}g} 匹配 a.png、a.jpg、a.jpeg {a..c}{1..2} 匹配 a1 a2 b1 b2 c1 c2 注意：{} 与 [] 有一个很重要的区别：如果匹配的文件不存在，[]会失去模式的功能，变成一个单纯的字符串，而 {} 依然可以展开。 小括号 概念：小括号必须跟在 ?、*、+、@、! 后面使用，且小括号里面的内容是一组以 | 分隔符的模式集合，例如：abc|a?c|ac*。 示例： ?(pattern|pattern|pattern)：匹配0次或1次给定的模式 *(pattern|pattern|pattern):匹配0次或多次给定的模式 +(pattern|pattern|pattern)：匹配1次或多次给定的模式 @(pattern|pattern|pattern)：严格匹配给定的模式 !(pattern|pattern|pattern)：匹配非给定的模式 应用场景 webpack 多页面应用自动打包配置 在一个 webpack 项目中，假如我们有多个入口，每个入口都有一个 index.html 模板和 index.js 文件，而且这个入口是动态变化的，不希望每增加一个入口就改 webpack.config.js 配置文件，应该怎么办呢？ 此时可以约定在 src 下面创建的文件夹，只要里面有 index.js，我们就把它当做一个入口文件进行打包： src ├── detail │ ├── index.html │ └── index.js ├── home │ ├── index.html │ └── index.js ├── login │ ├── index.html │ └── index.js ├── shop │ ├── index.html │ └── index.js 用 glob 很快就能写出下面的自动打包代码： const HtmlWebpackPlugin = require('html-webpack-plugin') const path = require('path') const glob = require('glob') // 动态生成 entry 和 html-webpack-plugin function getMpa() { const entry = {}, htmlPlugins = [] const files = glob.sync('src/*/index.js') files.forEach((file) => { const filename = file.split('/')[1] entry[filename] = path.join(__dirname, file) htmlPlugins.push( new HtmlWebpackPlugin({ template: path.join(__dirname, `src/${filename}/index.html`), filename: `${filename}.html`, chunks: [filename], }) ) }) return { entry, htmlPlugins } } const mpa = getMpa() // 动态的配置文件 module.exports = { entry: mpa.entry, output: { path: path.join(__dirname, 'dist'), filename: '[name]-[hash:6].js', }, plugins: [...mpa.htmlPlugins], } 这样，无论增加多少个入口，webpack.config.js 都不用变。 手写一个约定大于配置的 Node.js 框架 egg.js 是一款优秀的 Node.js 企业级开发框架，就应用了约定大于配置的思想，例如： 约定一个中间件是一个放置在 app/middleware 目录下的单独文件 约定了 app/router.js 文件用于统一所有路由规则 约定 Service 文件必须放在 app/service 目录，可以支持多级目录，访问的时候可以通过目录名级联访问 因为一个大规模的团队需要遵循一定的约束和约定，开发效率才更高，有了这些约定之后，我们就可以利用 glob 写出匹配规则，找到用户放到指定目录下的文件并进行动态加载了，一个最基础的 load 函数如下： function load(folder, options) { const extname = options.extname || '.{js,ts}' return glob.sync(require('path').join(folder, `./**/*.js`)).forEach((item) => require(item)) } 使用 glob，配合相应的规范，例如 RESTful，我们自己也能封装一个简易的、基于约定的 Node.js 框架了。 "},"rollup/0.0.0.html":{"url":"rollup/0.0.0.html","title":"佰.0.0 rollup 介绍","keywords":"","body":"rollup介绍 rollup文档 中文文档：https://www.rollupjs.com/ 官方文档：https://rollupjs.org/ 官方文档：https://rollupjs.org/guide/zh/ rollup是什么? rollup是一个JavaScript模块打包器，可以将小块代码编译成大块复杂的代码。 rollup有什么优势?（竞争力） rollup最大的亮点就是Tree-shaking，即可以静态分析代码中的import，并排除任何未使用的代码。这允许我们架构于现有工具和模块之上，而不会增加额外的依赖或使项目的大小膨胀。如果用webpack做，虽然可以实现tree-shaking，但是需要自己配置并且打包出来的代码非常臃肿，所以对于库文件和UI组件，rollup更加适合。 rollup适用于什么情况（什么时候使用rollup）? 对于库文件和UI组件，rollup更加适合 "},"rollup/0.0.1.html":{"url":"rollup/0.0.1.html","title":"佰.0.1 rollup 基础","keywords":"","body":"rollup基础 1，创建项目文件夹 mkdir 2，进入项目文件夹 cd 3，初始化项目 npm init -y 4，安装rollup（开发依赖） npm i -D rollup 5，安装balel插件（开发依赖），用于代码转换 // @babel/core：babel插件核心功能 // @babel/preset-env：env预设，用于把es高版本转换为es5代码 // @rollup/plugin-babel：连接rollup与babel npm i -D @babel/core @babel/preset-env @rollup/plugin-babel 6，创建babel配置文件：babel.config.js | babel.config.json | .babelrc { } 7，安装js代码压缩插件：rollup-plugin-terser（开发依赖） // rollup-plugin-terser：压缩js代码，包括es6代码压缩 npm i -D rollup-plugin-terser 8，其他必装插件：rollup-plugin-node-resolve && rollup-plugin-commonjs（开发依赖） // rollup-plugin-commonjs：用来将 CommonJS 模块转换为 ES2015 供 rollup 处理 // rollup-plugin-node-resolve：告诉 Rollup 如何查找外部模块 npm i -D rollup-plugin-node-resolve rollup-plugin-commonjs 9，rollup配置文件：rollup.config.js import babel from '@rollup/plugin-babel' export default { input: './src/index.js', output: { file: 'dist/vue.js', format: 'umd', name: 'Vue', sourcemap: true }, plugins: [ babel({ exclude: 'node_modules/**' }) ] } "},"rollup/0.0.2.html":{"url":"rollup/0.0.2.html","title":"佰.0.2 rollup 打包格式","keywords":"","body":"rollup打包格式 文档：https://www.rollupjs.com/guide/big-list-of-options#%E6%A0%BC%E5%BC%8Fformat--f--outputformat AMD Asynchronous Module Definition，可以看作CJS的异步版本，制定了一套规则使模块可以被异步require进来并在回调函数里继续使用，然后require.js等前端库也可以利用这个规则加载代码了，目前已经是时代的眼泪了。 CJS CommonJS，只能在NodeJS上运行，使用require(\"module\")读取并加载模块。 缺点：不支持浏览器，执行后才能拿到依赖信息，由于用户可以动态require（例如react根据开发和生产环境导出不同代码的写法），无法做到提前分析依赖以及Tree-Shaking。 UMD Universal Module Definition，同时兼容CJS和AMD，并且支持直接在前端用的方式加载。现在还在广泛使用，不过可以想象ESM和IIFE逐渐代替它。 ESM ECMAScript Module，现在使用的模块方案，使用import export来管理依赖。由于它们只能写在所有表达式外面，所以打包器可以轻易做到分析依赖以及Tree-Shaking。当然他也支持动态加载import()。 浏览器直接通过即可使用该写法。NodeJS可以通过使用mjs后缀或者在package.json添加\"type\": \"module\"来使用，注意他还有一些实验性的功能没有正式开启。考虑到大量cjs库没有支持，如果要发布esm版的库还是通过rollup打包一下比较好（同时相关依赖可以放到devDependencies里）。 IIFE Immediately Invoked Function Expression，只是一种写法，可以隐藏一些局部变量，前端人要是不懂这个可能学的是假前端。可以用来代替UMD作为纯粹给前端使用的写法。 "},"rollup/0.0.3.html":{"url":"rollup/0.0.3.html","title":"佰.0.3 rollup 插件及使用","keywords":"","body":"rollup插件及使用 babel代码转译 // 安装依赖 npm i -D @babel/core @babel/preset-env @rollup/plugin-babel // 使用前置条件，配置babel.config.js | babel.config.json | .babelrc // babel.config.json { \"presets\": [ [ \"@babel/preset-env\", { \"useBuiltIns\": \"entry\" } ] ] } // babel.config.js module.exports = { \"presets\": [ [ \"@babel/preset-env\", { \"useBuiltIns\": \"entry\" } ] ] } // .babelrc { \"presets\": [ [ \"@babel/preset-env\", { \"useBuiltIns\": \"entry\" } ] ] } // 使用：rollup.config.js文件配置如下 import babel from \"@rollup/plugin-babel\" export default { \"plugins\": [ babel({ exclude: 'node_modules/**' }) ] } 代码压缩：rollup-plugin-terser // 安装 npm i -D rollup-plugin-terser // 配置 import { terser } from \"rollup-plugin-terser\"; import babel from \"@rollup/plugin-babel\" export default { \"plugins\": [ babel({ exclude: 'node_modules/**' }), terser() ] } @rollup/plugin-node-resolve // 安装 yarn add -D @rollup/plugin-node-resolve // 配置 import { nodeResolve } from \"@@rollup/plugin-node-resolve\"; import { terser } from \"rollup-plugin-terser\"; import babel from \"@rollup/plugin-babel\" export default { \"plugins\": [ nodeResolve(), babel({ exclude: 'node_modules/**' }), terser() ] } "},"rollup/0.0.4.html":{"url":"rollup/0.0.4.html","title":"佰.0.4 rollup 配置文件内容","keywords":"","body":"rollup配置文件内容 安装依赖 npm i -D rollup npm i -D @bebal/core @babel/preset-env @rollup/plugin-babel npm i -D @rollup/plugin-commonjs @rollup/plugin-node-resolve npm i -D rollup-plugin-terser 配置内容（rollup.config.js） import commonjs from '@rollup/plugin-commonjs' import { nodeResolve } from \"@rollup/plugin-node-resolve\"; import { terser } from \"rollup-plugin-terser\"; import babel from \"@rollup/plugin-babel\" export default { \"input\": \"./src/index.js\", \"output\": { file: \"./dist/bundle.js\", format: \"UMD\", name: \"bundle\", sourcemap: true }, \"plugins\": [ commonjs(), nodeResolve(), babel({ exclude: 'node_modules/**' }), terser() ] } "},"vite/0.0.0.html":{"url":"vite/0.0.0.html","title":"千.0.0 vite 介绍","keywords":"","body":"vite 官方文档：https://vitejs.dev/ 官方中文文档：https://cn.vitejs.dev/ 特性 1，极速的服务启动：完全类型化的API 2，轻量快速的热重载：无论应用程序大小如何，都始终极快的模块热重载（HMR） 3，丰富的功能：对TypeScript、JSX、CSS等支持开箱即用。 4，优化的构建：可选 “多页应用” 或 “库” 模式的预配置Rollup构建 5，通用的插件：在开发和构建之间共享Rollup-superset插件接口。 6，完全类型化的API：灵活的API和完整的TypeScript类型。 为什么选Vite 官方说明：https://cn.vitejs.dev/guide/why.html "},"vite/0.0.1.html":{"url":"vite/0.0.1.html","title":"千.0.1 使用 vite 创建 vue3+ts 项目","keywords":"","body":"使用 vite创建 vue3+ts项目 创建项目 // 格式： yarn create vite --template vue-ts // 如： yarn create vite myapp --template vue-ts 安装依赖 yarn 启动项目 yarn dev 使用@代替src 1，在vite.config.js配置文件中增加resolve.alias配置，如下 import { defineConfig } from \"vite\"; import vue from \"@vitejs/plugin-vue\"; export default defineConfig({ plugins: [vue()], // 增加resolve.alias配置 // 此操作后有，项目已经支持了，但是ts依然会飘红，处理方法在下面 resolve: { alias: { \"@\": \"/src\", }, }, }); 2，处理ts飘红：修改项目根目录下的tsconfig.json文件，增加compilerOptions.baseUrl和compilerOptions.paths配置字段 { compilerOptions: { \"baseUrl\": \"./\", \"paths\": { \"@/*\": [\"src/*\"] } } } 集成 vue-router 1，安装 yarn add vue-router 2，创建3个页面视图，如下： // 1，src/pages/home/index.vue import { ref } from 'vue' const msg = ref('home') // 2，src/pages/list/index.vue import { ref } from 'vue' const msg = ref('list') // 3，src/pages/info/index.vue import { ref } from 'vue' const msg = ref('info') 3，创建 src/router/router.ts文件，内容如下 import { createRouter, createWebHistory } from 'vue-router' const routes = [ { path: '/', name: 'home', component: ()=>import('@/pages/home/index.vue') }, { path: '/list', name: 'list', component: ()=>import('@/pages/list/index.vue') }, { path: '/info', name: 'info', component: ()=>import('@/pages/info/index.vue') }, ] const router = createRouter({ history: createWebHistory(), routes }) export default router 3，在 main.ts文件中引入 router.js文件，main.ts内容如下： import { createApp } from 'vue' import router from '@/router/router' import App from '@/App.vue' createApp(App).use(router).mount('#app') 集成 sass 安装 sass即可 yarn add sass -D // 需要重新启动 集成 axios yarn add axios 关于axios的使用和封装、拦截等操作暂不叙述 集成Pinia（状态管理） 1，安装 yarn add pinia 2，使用：见官网 eslint && prettier 1，eslint分为npm包和vscode插件 // npm包只是用来检测语法是否符合定义的规范， // 并且要主动使用命令校验才会检测代码是否符合规范， // 针对不符合规范的语法代码也只能进行部分修复，比如缩进、单双引号、是否加分号等 /**************** 因此需要eslint的插件的配合 *****************/ // eslint插件可以配置为：当保存时自动校验代码并且格式化 // 一般不会使用eslint的格式化功能，会采用prettier的格式化功能 2，prettier也分为npm包和vscode插件 集成husky "},"vite/0.0.2.html":{"url":"vite/0.0.2.html","title":"千.0.2 vue2 中使用 vite","keywords":"","body":"vue2中使用vite (壹)、初始化项目 yarn create vite ? Select a framework: vanilla (这个地方选择原生，选vue的话默认vue3.0) (贰)、安装插件 yarn add vite-plugin-vue2 -D (叁)、创建配置文件：vite.config.js import { createVuePlugin } from 'vite-plugin-vue2' export default { plugins: [createVuePlugin()] } (肆)、安装vue(需指定版本) && vue-template-compiler yarn add vue@2.6.14 vue-template-compiler (伍)、修改目录 && 文件 1，根目录新建src文件夹，并把根目录下的main.js文件移到src目录下，main.js的内容如下 import Vue from 'vue' import App from './App.vue' new Vue({ render: h => h(App) }).$mount('#app') 2，src目录下创建App.vue文件，App.vue的内容如下： Hello Vite Vue2 3，index.html文件中引入的main.js路径变为如下： (陸)、启动项目 yarn dev (柒)、集成vue-router路由(需指定3.x.x版本) 1，安装vue-router yarn add vue-router@3.5.3 2，创建路由文件(src/router/router.js)，并配置路由信息 // src/router/router.js import Vue from 'vue' import Router from \"vue-router\"; Vue.use(Router) const routes = [ { path: \"/login\", name: \"login\", component: () => import(\"../pages/login.vue\"), }, { path: \"/list\", name: \"list\", component: () => import(\"../pages/list.vue\"), }, ] const router = new Router({ mode: 'history', routes }); export default router; 3，main.js文件内容修改如下 import Vue from 'vue' import router from './router/router.js' import App from './App.vue' new Vue({ router, render: h => h(App) }).$mount('#app') (捌)、集成vuex(需指定版本)状态管理 1，安装vuex，版本为3.x.x yarn add vuex@3.6.2 2，创建store.js文件(src/store/store.js)，并配置相关内容 import Vue from \"vue\"; import Vuex from \"vuex\"; Vue.use(Vuex); export default new Vuex.Store({ state: { count: 0, }, //同步方法 mutations: { SET_COUNT(state) { state.count += 1 }, }, }); 3，main.js文件内容修改如下 import Vue from 'vue' import router from './router/router.js' import store from './store/store.js' import App from './App.vue' new Vue({ store, router, render: h => h(App) }).$mount('#app') (玖)、集成axios发送请求 1，安装axios yarn add axios 2，配置，修改main.js如下： import Vue from 'vue' import router from './router/router.js' import store from './store/store.js' import axios from 'axios' import App from './App.vue' Vue.prototype.$axios = axios new Vue({ store, router, render: h => h(App) }).$mount('#app') 3，使用 export default { methods: { async getList() { const res = await this.$axios.get(\"/mock/getList.json\"); console.log(res.data.data); } } } (拾)、sass支持 Vite 也同时提供了对 .scss, .sass, .less, .styl 和 .stylus 文件的内置支持，只需安装相应的预处理器依赖 文档：https://cn.vitejs.dev/guide/features.html#css-pre-processors yarn add sass -D "},"vite/0.0.3.html":{"url":"vite/0.0.3.html","title":"千.0.3 集成 eslint && prettier","keywords":"","body":"集成 eslint && prettier eslint 是做什么的? eslint 用来制定代码书写规范，并检测书写的代码是否符合制定的代码规范 eslint 可以针对不符合规范的代码进行部分修复--fix prettire 是做什么的 prettier(code formatter) 用来按照指定的规范去格式化书写的代码 集成 eslint eslint 分为 npm 包和 vs code 插件 npm 包只有主动使用命令校验才会检查代码是否符合规范，因此 vs code 中才会有 eslint 插件，用来实时检验代码是否符合规范 并且 eslint 的修复功能也要在保存代码时自动修复 "},"three/0.0.0.html":{"url":"three/0.0.0.html","title":"萬.0.0 学习资源","keywords":"","body":"学习资源 1，官方网站：https://threejs.org/ 2，官方文档：https://threejs.org/docs/ 3，官方手册：https://threejs.org/manual/ 4，入门视频：快速上手 Three.js 基础 1，官方手册： https://threejs.org/manual/#zh/fundamentals https://threejs.org/manual/#zh/primitives https://threejs.org/manual/#zh/scenegraph ... 示例demo https://threejs.org/examples/#css3d_periodictable 3D模型网站 https://sketchfab.com/ 博客文章 https://ericli.blog.csdn.net/article/details/117667697?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1.pc_relevant_aa&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1.pc_relevant_aa&utm_relevant_index=2 https://blog.csdn.net/qq_30100043/category_7003591.html https://blog.csdn.net/u014291990/category_8071173_3.html "},"three/0.0.1.html":{"url":"three/0.0.1.html","title":"萬.0.1 知识点","keywords":"","body":"知识点 创建渲染器 // 创建渲染器，默认会创建一个canvas元素对象 const renderer = new THREE.WebGLRenderer(); // 设置渲染区域大小 renderer.setSize(300, 300); // 将默认创建的canvas元素填充到页面 document.body.appendChild(renderer.domElement); // 创建渲染器时，传入canvas参数，则不需要设置渲染区域的大小(默认为canvas的大小)，也不需要填充到页面(canvas本身就在页面中，本身就是dom元素) const renderer = new THREE.WebGLRenderer({ canvas: document.querySelector(\"#myCanvas\"), }); 创建相机 1，透视相机 // 视角，fov的值越大，里面的图形会显得越小。这是为什么？虽然正方体的实际大小并未改变，但是将照相机的竖直张角设置更大时，可视区域变大了，因而正方体相对于整个可视区域的大小就变小了，看起来正方形就显得变小了。 const fov = 45; // 宽高比 const aspect = window.innerWidth / window.innerHeight; // 近 const near = 0.1; // 远 const far = 10; // 创建透视相机 const camera = new THREE.PerspectiveCamera(fov, aspect, near, far); // 设置相机的位置，默认位置为(0,0,0) camera.position.set(0, 0, 2); // 或 camera.position.x = 0; camera.position.y = 0; camera.position.z = 2; 2，正交相机 // THREE.OrthographicCamera(left, right, top, bottom, near, far) const camera = new THREE.OrthographicCamera(); 光源 1，点光源（PointLight） const color = \"0xff0000\"; // 光照颜色 const intensity = 1; // 光照强度 const distance = 0; // 距离：从光源到光照强度为0的位置，当设置为0时，光永远不会消失(距离无穷大) const decay = 1; // 光照距离的衰退量 const light = new THREE.PointLight(color, intensity); 2，平行光（DirectionalLight） const color = \"0xffffff\"; // - (参数可选）颜色的rgb数值。缺省值为 0xffffff。 const intensity = 1; // - (参数可选)光照的强度。缺省值为 1。 // 创建一个环境光对象。 const light = new THREE.DirectionalLight(color, intensity); 3，环境光（AmbientLight） const color = \"0xffffff\"; // - (可选参数) 16进制表示光的颜色。 缺省值为 0xffffff (白色)。 const intensity = 1; // - (可选参数) 光照的强度。缺省值为1。 // 创建一个新的 DirectionalLight。 const light = new THREE.AmbientLight(color, intensity); 坐标轴 // 辅助坐标轴 const axesHelper = new AxesHelper(1); scene.add(axesHelper); // 如果不显示z轴，调整下相机的位置即可 camera.position.set(0, 1, 2); 创建几何体 1，BoxGeometry（立方体） const geometry = new THREE.BoxGeometry(1, 1, 1); // 或 const geometry = new THREE.BoxGeometry(1, 1, 1, 2, 2, 2); 2，SphereGeometry（球体） // 球体半径 const radius = 10; // 水平分段数 const widthSegments = 32; // 垂直分段数 const heightSegments = 16; // 创建球体 const geometry = new THREE.SphereGeometry( radius, widthSegments, heightSegments ); ... 网格材质 网格基础材质(MeshBasicMaterial) 该材质不受光照的影响，不需要光源即可显示出来，设置颜色后，各个面都是同一个颜色。 网格法向材质(MeshNormalMaterial) 该材质不受光照的影响，不需要光源即可显示出来，并且每个方向的面的颜色都不同，同但一个方向的面颜色是相同的，该材质一般用于调试。 网格朗博材质(MeshLambertMaterial) 该材质会受到光照的影响，没有光源时不会显示出来，用于创建表面暗淡，不光亮的物体。 网格Phong材质(MeshPhongMaterial) 该材质会受到光照的影响，没有光源时不会显示出来，用于创建光亮的物体。 控制器 1，OrbitControls：Three.js 使用 orbit controls 插件（轨道控制）来控制模型交互动作 const controls = new THREE.OrbitControls(camera, renderer.domElement); // 如果使用animate方法时，将此函数删除 //controls.addEventListener( 'change', render ); // 使动画循环使用时阻尼或自转 意思是否有惯性 controls.enableDamping = true; //动态阻尼系数 就是鼠标拖拽旋转灵敏度 //controls.dampingFactor = 0.25; //是否可以缩放 controls.enableZoom = true; //是否自动旋转 controls.autoRotate = true; //设置相机距离原点的最远距离 controls.minDistance = 200; //设置相机距离原点的最远距离 controls.maxDistance = 600; //是否开启右键拖拽 controls.enablePan = true; function animate() { requestAnimationFrame(animate); //更新控制器 controls.update(); renderer.render(scene, camera) //更新性能插件 stats.update(); } animate() 2，TrackballControls：Three.js 使用轨迹球插件（trackball）增加对模型的交互功能 // 用户交互插件 - 鼠标左键按住旋转，右键按住平移，滚轮缩放 const controls = new THREE.TrackballControls(camera); //旋转速度 controls.rotateSpeed = 5; //变焦速度 controls.zoomSpeed = 3; //平移速度 controls.panSpeed = 0.8; //是否不变焦 controls.noZoom = false; //是否不平移 controls.noPan = false; //是否开启移动惯性 controls.staticMoving = false; //动态阻尼系数 就是灵敏度 controls.dynamicDampingFactor = 0.3; //未知，占时先保留 //controls.keys = [ 65, 83, 68 ]; controls.addEventListener(\"change\", render); function animate() { requestAnimationFrame(animate); //更新控制器 controls.update(); // 渲染画面 renderer.render(scene, camera); } animate(); 加载器 "},"three/0.0.2.html":{"url":"three/0.0.2.html","title":"萬.0.2 阴影四步走","keywords":"","body":"阴影四步走 注意：需要使用可以接受光的材质，如：MeshLambertMaterial、MeshStandardMaterial、MeshPhongMaterial等 参考文档：https://blog.csdn.net/qq_30100043/article/details/76177338 // 1，告诉渲染器需要阴影效果 renderer.shadowMap.enabled = true; // 2，告诉平行光需要开启阴影投射 light.castShadow = true; // 3，告诉立方体需要投射阴影 cube.castShadow = true; // 4，告诉底部平面需要接收阴影 plane.receiveShadow = true; "},"senior/0.0.0.html":{"url":"senior/0.0.0.html","title":"亿.0.0 数据响应式原理","keywords":"","body":"数据响应式原理 "},"senior/0.0.1.html":{"url":"senior/0.0.1.html","title":"亿.0.1 双向数据绑定原理","keywords":"","body":"双向数据绑定原理 "},"senior/0.0.2.html":{"url":"senior/0.0.2.html","title":"亿.0.2 MVVM 原理","keywords":"","body":"MVVM原理 "},"senior/0.0.3.html":{"url":"senior/0.0.3.html","title":"亿.0.3 实现虚拟 DOM","keywords":"","body":"实现虚拟DOM 最近一两年前端最火的技术莫过于ReactJS，即便你没用过也该听过，ReactJS由业界顶尖的互联网公司facebook提出，其本身有很多先进的设计思路，比如页面UI组件化、虚拟DOM等。本文将带你解开虚拟DOM的神秘面纱，不仅要理解其原理，而且要实现一个基本可用的虚拟DOM。 1.为什么需要虚拟DOM DOM是很慢的，其元素非常庞大，页面的性能问题鲜有由JS引起的，大部分都是由DOM操作引起的。如果对前端工作进行抽象的话，主要就是维护状态和更新视图；而更新视图和维护状态都需要DOM操作。其实近年来，前端的框架主要发展方向就是解放DOM操作的复杂性。 在jQuery出现以前，我们直接操作DOM结构，这种方法复杂度高，兼容性也较差；有了jQuery强大的选择器以及高度封装的API，我们可以更方便的操作DOM，jQuery帮我们处理兼容性问题，同时也使DOM操作变得简单；但是聪明的程序员不可能满足于此，各种MVVM框架应运而生，有angularJS、avalon、vue.js等，MVVM使用数据双向绑定，使得我们完全不需要操作DOM了，更新了状态视图会自动更新，更新了视图数据状态也会自动更新，可以说MMVM使得前端的开发效率大幅提升，但是其大量的事件绑定使得其在复杂场景下的执行性能堪忧；有没有一种兼顾开发效率和执行效率的方案呢？ReactJS就是一种不错的方案，虽然其将JS代码和HTML代码混合在一起的设计有不少争议，但是其引入的Virtual DOM(虚拟DOM)却是得到大家的一致认同的。 2.理解虚拟DOM 虚拟的DOM的核心思想是：对复杂的文档DOM结构，提供一种方便的工具，进行最小化地DOM操作。这句话，也许过于抽象，却基本概况了虚拟DOM的设计思想 (1) 提供一种方便的工具，使得开发效率得到保证 (2) 保证最小化的DOM操作，使得执行效率得到保证 (1).用JS表示DOM结构 DOM很慢，而javascript很快，用javascript对象可以很容易地表示DOM节点。DOM节点包括标签、属性和子节点，通过VElement表示如下。 //虚拟dom，参数分别为标签名、属性对象、子DOM列表 var VElement = function(tagName, props, children) { //保证只能通过如下方式调用：new VElement if (!(this instanceof VElement)) { return new VElement(tagName, props, children); } //可以通过只传递tagName和children参数 if (util.isArray(props)) { children = props; props = {}; } //设置虚拟dom的相关属性 this.tagName = tagName; this.props = props || {}; this.children = children || []; this.key = props ? props.key : void 666; var count = 0; util.each(this.children, function(child, i) { if (child instanceof VElement) { count += child.count; } else { children[i] = '' + child; } count++; }); this.count = count; } 通过VElement，我们可以很简单地用javascript表示DOM结构。比如 var vdom = velement('div', { 'id': 'container' }, [ velement('h1', { style: 'color:red' }, ['simple virtual dom']), velement('p', ['hello world']), velement('ul', [velement('li', ['item #1']), velement('li', ['item #2'])]), ]); 上面的javascript代码可以表示如下DOM结构： simple virtual dom hello world item #1 item #2 同样我们可以很方便地根据虚拟DOM树构建出真实的DOM树。具体思路：根据虚拟DOM节点的属性和子节点递归地构建出真实的DOM树。见如下代码： VElement.prototype.render = function() { //创建标签 var el = document.createElement(this.tagName); //设置标签的属性 var props = this.props; for (var propName in props) { var propValue = props[propName] util.setAttr(el, propName, propValue); } //依次创建子节点的标签 util.each(this.children, function(child) { //如果子节点仍然为velement，则递归的创建子节点，否则直接创建文本类型节点 var childEl = (child instanceof VElement) ? child.render() : document.createTextNode(child); el.appendChild(childEl); }); return el; } 对一个虚拟的DOM对象VElement，调用其原型的render方法，就可以产生一颗真实的DOM树。 vdom.render(); 既然我们可以用JS对象表示DOM结构，那么当数据状态发生变化而需要改变DOM结构时，我们先通过JS对象表示的虚拟DOM计算出实际DOM需要做的最小变动，然后再操作实际DOM，从而避免了粗放式的DOM操作带来的性能问题。 (2).比较两棵虚拟DOM树的差异 在用JS对象表示DOM结构后，当页面状态发生变化而需要操作DOM时，我们可以先通过虚拟DOM计算出对真实DOM的最小修改量，然后再修改真实DOM结构(因为真实DOM的操作代价太大)。 如下图所示，两个虚拟DOM之间的差异已经标红： 为了便于说明问题，我当然选取了最简单的DOM结构，两个简单DOM之间的差异似乎是显而易见的，但是真实场景下的DOM结构很复杂，我们必须借助于一个有效的DOM树比较算法。 设计一个diff算法有两个要点： 如何比较两个两棵DOM树 如何记录节点之间的差异 如何比较两个两棵DOM树 计算两棵树之间差异的常规算法复杂度为O(n3)，一个文档的DOM结构有上百个节点是很正常的情况，这种复杂度无法应用于实际项目。针对前端的具体情况：我们很少跨级别的修改DOM节点，通常是修改节点的属性、调整子节点的顺序、添加子节点等。因此，我们只需要对同级别节点进行比较，避免了diff算法的复杂性。对同级别节点进行比较的常用方法是深度优先遍历： function diff(oldTree, newTree) { //节点的遍历顺序 var index = 0; //在遍历过程中记录节点的差异 var patches = {}; //深度优先遍历两棵树 dfsWalk(oldTree, newTree, index, patches); return patches; } 如何记录节点之间的差异 由于我们对DOM树采取的是同级比较，因此节点之间的差异可以归结为4种类型： 修改节点属性, 用PROPS表示 修改节点文本内容, 用TEXT表示 替换原有节点, 用REPLACE表示 调整子节点，包括移动、删除等，用REORDER表示 对于节点之间的差异，我们可以很方便地使用上述四种方式进行记录，比如当旧节点被替换时： {type:REPLACE,node:newNode} 而当旧节点的属性被修改时： {type:PROPS,props: newProps} 在深度优先遍历的过程中，每个节点都有一个编号，如果对应的节点有变化，只需要把相应变化的类别记录下来即可。下面是具体实现： function dfsWalk(oldNode, newNode, index, patches) { var currentPatch = []; if (newNode === null) { //依赖listdiff算法进行标记为删除 } else if (util.isString(oldNode) && util.isString(newNode)) { if (oldNode !== newNode) { //如果是文本节点则直接替换文本 currentPatch.push({ type: patch.TEXT, content: newNode }); } } else if (oldNode.tagName === newNode.tagName && oldNode.key === newNode.key) { //节点类型相同 //比较节点的属性是否相同 var propsPatches = diffProps(oldNode, newNode); if (propsPatches) { currentPatch.push({ type: patch.PROPS, props: propsPatches }); } //比较子节点是否相同 diffChildren(oldNode.children, newNode.children, index, patches, currentPatch); } else { //节点的类型不同，直接替换 currentPatch.push({ type: patch.REPLACE, node: newNode }); } if (currentPatch.length) { patches[index] = currentPatch; } } 比如对上文图中的两颗虚拟DOM树，可以用如下数据结构记录它们之间的变化： var patches = { 1:{type:REPLACE,node:newNode}, //h1节点变成h5 5:{type:REORDER,moves:changObj} //ul新增了子节点li } (3).对真实DOM进行最小化修改 通过虚拟DOM计算出两颗真实DOM树之间的差异后，我们就可以修改真实的DOM结构了。上文深度优先遍历过程产生了用于记录两棵树之间差异的数据结构patches, 通过使用patches我们可以方便对真实DOM做最小化的修改。 //将差异应用到真实DOM function applyPatches(node, currentPatches) { util.each(currentPatches, function(currentPatch) { switch (currentPatch.type) { //当修改类型为REPLACE时 case REPLACE: var newNode = (typeof currentPatch.node === 'String') ? document.createTextNode(currentPatch.node) : currentPatch.node.render(); node.parentNode.replaceChild(newNode, node); break; //当修改类型为REORDER时 case REORDER: reoderChildren(node, currentPatch.moves); break; //当修改类型为PROPS时 case PROPS: setProps(node, currentPatch.props); break; //当修改类型为TEXT时 case TEXT: if (node.textContent) { node.textContent = currentPatch.content; } else { node.nodeValue = currentPatch.content; } break; default: throw new Error('Unknow patch type ' + currentPatch.type); } }); } 至此，虚拟DOM的基本原理已经基本讲解完成了；我们也一起实现了一个基本可用的虚拟DOM。 "},"senior/0.0.4.html":{"url":"senior/0.0.4.html","title":"亿.0.4 发布订阅模式","keywords":"","body":"发布订阅模式 /** * @author mrdoob / http://mrdoob.com/ * @homepage / https://github.com/mrdoob/eventdispatcher.js */ class EventDispatcher { addEventListener( type, listener ) { if ( this._listeners === undefined ) this._listeners = {}; const listeners = this._listeners; if ( listeners[ type ] === undefined ) { listeners[ type ] = []; } if ( listeners[ type ].indexOf( listener ) === - 1 ) { listeners[ type ].push( listener ); } } hasEventListener( type, listener ) { if ( this._listeners === undefined ) return false; const listeners = this._listeners; return listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1; } removeEventListener( type, listener ) { if ( this._listeners === undefined ) return; const listeners = this._listeners; const listenerArray = listeners[ type ]; if ( listenerArray !== undefined ) { const index = listenerArray.indexOf( listener ); if ( index !== - 1 ) { listenerArray.splice( index, 1 ); } } } dispatchEvent( event ) { if ( this._listeners === undefined ) return; const listeners = this._listeners; const listenerArray = listeners[ event.type ]; if ( listenerArray !== undefined ) { event.target = this; // Make a copy, in case listeners are removed while iterating. const array = listenerArray.slice( 0 ); for ( let i = 0, l = array.length; i "}}