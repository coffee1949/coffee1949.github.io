{"./":{"url":"./","title":"前言.写给有缘人","keywords":"","body":"前言·写给有缘人 01.codeing到80岁 作为一个老程序员，codeing已经成为生命的一部分，coding到八十岁是我的理想，而JavaScript是我挚爱的语言！ 自从2010年出版个人第一本互联网技术书籍后，便再也没有时间可以写系统性论述技术的著作。因为后来加入奇虎360和百度这两家一线互联网公司，从事前端与手机客户端技术性工作，并主持研发了亿级用户的手机APP，这期间相当繁忙。 在接受了一线互联网企业的再锻造与重塑之后，编程工作就像打游戏一样，让我觉得快乐与充实。每天都能“通关”，解决掉一个又一个问题，与优秀的聪明的睿智的热心的同事们一起协同合作，创造一个又一个生动有趣的产品，成就感是满满的……而且最重要的，在这个过程中居然还能赚到不少钱，让我作为一个程序员能够体面地生活并做自己喜欢的事，这实在是太美妙了！ "},"gitbook/0.0.0.html":{"url":"gitbook/0.0.0.html","title":"零.0.0 从零开始使用 gitbook 搭建文档站点","keywords":"","body":"从零开始使用gitbook搭建文档站点 安装gitbook-cli脚手架工具 npm i -g gitbook-cli 查看安装版本 gitbook --version gitbook -V 初始化项目 // 执行如下命令会在当前目录下生成2个文件（README.md && SUMMARY.md） gitbook init // 执行如下命令会在当前的note文件夹下生产2个文件（README.md && SUMMARY.md） // 如果没有note文件夹，会先创建note文件夹 git init ./note 注意1：执行gitbook init命令如果报如下错误： Installing GitBook 3.2.3 SOLINK_MODULE(target) Release/.node CXX(target) Release/obj.target/fse/fsevents.o SOLINK_MODULE(target) Release/fse.node SOLINK_MODULE(target) Release/.node CXX(target) Release/obj.target/fse/fsevents.o SOLINK_MODULE(target) Release/fse.node /usr/local/lib/node_modules/gitbook-cli/node_modules/npm/node_modules/graceful-fs/polyfills.js:287 if (cb) cb.apply(this, arguments) ^ TypeError: cb.apply is not a function at /usr/local/lib/node_modules/gitbook-cli/node_modules/npm/node_modules/graceful-fs/polyfills.js:287:18 at FSReqCallback.oncomplete (fs.js:184:5) 关键信息 TypeError: cb.apply is not a function at /usr/local/lib/node_modules/gitbook-cli/node_modules/npm/node_modules/graceful-fs/polyfills.js:287:18 解决方法：修改polyfills.js文件内容，注释一下三行内容（62行左右） // fs.stat = statFix(fs.stat) // fs.fstat = statFix(fs.fstat) // fs.lstat = statFix(fs.lstat) 注意2：执行gitbook init命令如果报如下错误： 原因：node版本太高，进行降级处理或者不处理此报错，手动创建SUMMARY.md文件 warn: no summary file in this book info: create README.md info: create SUMMARY.md TypeError [ERR_INVALID_ARG_TYPE]: The \"data\" argument must be of type string or an instance of Buffer, TypedArray, or DataView. Received an instance of Promise 启动项目（本地服务器） gitbook serve 打包项目 gitbook build SUMMARY.md书写格式如下 # Summary * [前言.写给有缘人](README.md) ### 零、GITBOOK * [零.0.0 从零开始使用gitbook搭建文档站点](0/0.0.0.md) * [零.0.1 gitbook插件集合](0/0.0.1.md) ### 佰、ROLLUP * [佰.0.0 rollup介绍](100/100.0.0.md) * [佰.0.1 rollup基础](100/100.0.1.md) gitbook之配置文件book.json // root：配置README.md && SUMMARY.md的位置 { \"root\": \"./docs\", \"title\": \"codeing\", \"description\": \"codeing...\", \"language\": \"zh-hans\", \"@styles\": { \"website\": \"./styles/website.css\" }, \"@links\": { \"sidebar\": { \"知乎\": \"https://www.zhihu.com/people/codeing.cn\", \"gitbook\": \"https://zhuanlan.zhihu.com/p/34946169\", \"前端内参\": \"https://coffe1891.gitbook.io\", \"如何学习\": \"https://juejin.cn/post/6960892566921281543\" } }, \"plugins\": [ \"-search\", \"search-pro\" ] } "},"gitbook/0.0.1.html":{"url":"gitbook/0.0.1.html","title":"零.0.1 gitbook 插件集合","keywords":"","body":"GITBOOK插件集合 介绍一下gitbook中book.json的一些实用配置和插件 全局配置 title 设置本书的标题（书名） \"title\": \"前端系列文章\" author 本书的作者的相关信息 \"author\": \"codeing.cn\" description 本书的简单描述 \"description\": \"记录与分享前端相关技术系列文章\" language 配置本书使用的语言 // 配置使用简体中文 \"language\": \"zh-hans\" links 配置在左侧导航栏的链接 \"links\": { \"sidebar\": { \"Home\": \"https://www.zhihu.com/people/codeing.cn\" } } styles 自定义页面样式，默认情况下各generator对应的css文件如下 \"styles\": { \"website\": \"styles/website.css\", \"ebook\": \"styles/ebook.css\", \"pdf\": \"styles/pdf.css\", \"mobi\": \"styles/mobi.css\", \"epub\": \"styles/epub.css\" } 例如使 标签有下边框， 可以在website.css中设置 h1 , h2{ border-bottom: 1px solid #EFEAEA; } 插件相关 plugins 配置使用的插件 \"plugins\": [ \"-search\", \"back-to-top-button\", \"expandable-chapters-small\", \"insert-logo\" ] 其中\"-search\"中的 - 符号代表去除默认自带的插件 // Gitbook默认自带有5个插件: highlight // 代码高亮 search // 导航栏查询功能（不支持中文） sharing // 右上角分享功能 font-settings // 字体设置（最上方的\"A\"符号） livereload // 为GitBook实时重新加载 pluginsConfig 配置插件的属性 // 配置insert-logo的属性 \"pluginsConfig\": { \"insert-logo\": { \"url\": \"images/logo.png\", \"style\": \"background: none; max-height: 30px; min-height: 30px\" } } "},"vscode/0.0.0.html":{"url":"vscode/0.0.0.html","title":"零.0.0 前端必装插件","keywords":"","body":"前端必装插件 chinese language pack for ... debugger for chrome auto close tag auto rename tag live server // 启动本地服务 open in browser power mode // 编码光标显示特效 svg preview // svg预览 prettier - code formatter vetur // vue2开发必装 volar // vue3开发必装 vscode-icons // vscode文件&文件夹图标 eslint git graph // git commit 记录查看 vscode 用户设置 // 保存文件时自动format格式化 \"editor.formatOnSave\": true, // 默认格式化工具，pritter \"editor.defaultFormatter\": \"esbenp.prettier-vscode\", // 终端默认打开为git bash \"terminal.integrated.defaultProfile.windows\": \"Git Bash\", "},"css/0.0.0.html":{"url":"css/0.0.0.html","title":"贰.0.0 css reset","keywords":"","body":"reset.scss && common.scss && global.scss reset.scss reset css common.scss 1，padding && margin @for $i from 1 through 6 { // padding .p-#{$i*5} { padding: #{$i * 5}px; } // padding-left .pl-#{$i*5} { padding-left: #{$i * 5}px; } // padding-right .pr-#{$i*5} { padding-right: #{$i * 5}px; } // padding-top .pt-#{$i*5} { padding-top: #{$i * 5}px; } // padding-bottom .pb-#{$i*5} { padding-bottom: #{$i * 5}px; } // 水平方向 .px-#{$i*5} { padding-left: #{$i * 5}px; padding-right: #{$i * 5}px; } // 垂直方向 .py-#{$i*5} { padding-top: #{$i * 5}px; padding-bottom: #{$i * 5}px; } // margin .m-#{$i*5} { margin: #{$i * 5}px; } // margin-left .ml-#{$i*5} { margin-left: #{$i * 5}px; } // margin-right .mr-#{$i*5} { margin-right: #{$i * 5}px; } // margin-top .mt-#{$i*5} { margin-top: #{$i * 5}px; } // margin-bottom .mb-#{$i*5} { margin-bottom: #{$i * 5}px; } // 水平方向 .mx-#{$i*5} { margin-left: #{$i * 5}px; margin-right: #{$i * 5}px; } // 垂直方向 .my-#{$i*5} { margin-top: #{$i * 5}px; margin-bottom: #{$i * 5}px; } } 2，flex布局 .d-flex{ display: flex; } .flex-col { flex-direction: column; } .jc-center { justify-content: center; } .jc-around { justify-content: space-around; } .jc-between { justify-content: space-between; } .ai-center { align-items: center; } .flex-1 { flex: 1; overflow: auto; } .center { display: flex; align-items: center; justify-content: center; } .flex-wrap{ flex-wrap: wrap; } global.scss 根据不同的项目不同 1，主题色 $them-color: pink; "},"css/0.0.1.html":{"url":"css/0.0.1.html","title":"贰.0.1 grid布局","keywords":"","body":"grid布局 "},"git/0.0.0.html":{"url":"git/0.0.0.html","title":"肆.0.0 基本用法","keywords":"","body":"基本用法 配置 // 设置用户名和邮箱 git config --global user.email \"you@example.com\" git config --global user.name \"Your Name\" // 查看全局配置 git config --global --list git stash // 保存状态 git stash // 查看 git stash list // 恢复 // pop状态恢复并删除记录，apply状态恢复，drop删除记录 git stash pop || git stash apply && git stash drop 分支 // git pull 确保本地分支是新的 // 查看本地分支 git branch // 查看远程分支 git branch -r // 查看所有分支 git branch -a // 新建本地分支：dev git branch dev // 切换到本地dev分支 git checkout dev // 新建本地分支issue-001并切换到issue-001分支 git checkout -b issue-001 // 新建本地分支并追踪远端分支：根据远程分支新建本地分支 && 建立关联关系 git checkout -b release/release1.15.1 origin/release/release1.15.1 // 新建本地分支，并切换到新建的本地分支，拉取对应远程分支内容，并追踪远程分支（与远程分支关联） // 方式一 git branch branchName // 新建与远程分支相对应的分支 git checkout branchName // 切换到新建分支 git pull origin branchName // 更新新分支数据，与远程进行同步 // -u 是 --set-upstream 的简写形式，本地分支与远程分支关联 git push -u origin branchName || git push --set-upstream origin feature // 方式二 git branch branchName git checkout branchName git pull origin branchName // 更新新分支数据，与远程分支进行同步 // 本地分支与远程分支关联 git branch --set-upstream-to=origin/branchName branchName // 关联后以后直接 git push 就可以了 git push // 新建远程分支的二种方式 // 方式一：直接在github或者gitee等代码托管平台新建分支 // 方式二：把本地当前分支push到远程分支 git push origin // 删除本地分支 git branch -d branchName git branch -D branchName // 强制删除 // 删除远程分支 git push origin --delete branchName git log查看日志 git reflog查看commits push后撤销push操作 // 先在本地回退到相应的版本： git reset --hard // 注意使用 --hard 参数会抛弃当前工作区的修改 // 使用 --soft 参数的话会回退到之前的版本，但是保留当前工作区的修改，可以重新提交 // 如果此时使用命令： git push origin // 会提示本地的版本落后于远端的版本； // 为了覆盖掉远端的版本信息，使远端的仓库也回退到相应的版本，需要加上参数--force git push origin --force 撤销工作空间（还没 git add）的更改 // 撤销单个或多个 git restore ... // 撤销全部 git restore . 撤销暂存（已经 git add）的更改 git restore --staged ... git restore --staged . "},"git/0.0.1.html":{"url":"git/0.0.1.html","title":"肆.0.1 回退版本：本地 && 远程","keywords":"","body":"回退版本：本地 && 远程 // 本地回退到指定commit_id git reset --hard 30e889e79b8 // 远程同步 git push origin release/1.23.1 --force "},"git/0.0.2.html":{"url":"git/0.0.2.html","title":"肆.0.2 打标签","keywords":"","body":"打标签 // 本地新增有备注的tag（默认在当前分支最后一个commit上添加tag） git tag -a v1.1.1 -m \"测试\" // git tag -a 标签名 -m “备注内容” // 将tag推送到远程分支 git push origin v1.1.0 // git push origin 标签名 // 查询本地所有tag git tag // 本地新增无备注的tag（默认在当前分支最后一个commit上添加tag） git tag v1.1.0 // git tag 标签名 // 本地新增有备注的tag（默认在当前分支最后一个commit上添加tag） git tag -a v1.1.1 -m \"测试\" // git tag -a 标签名 -m “备注内容” // 在指定commit上新增tag // git tag 标签名 commit（前几位也可以，尝试过最低3位报错，最好5位以上） git tag v1.1.0 105851905c8a0f9cc040cf845b35c1ced1963fcc // 将tag推送到远程分支 git push origin v1.1.0 // git push origin 标签名 // 删除本地分支标签 git tag -d v1.1.0 // git tag -d 标签名 // 删除远程分支标签 git push origin :refs/tags/v1.1.0 // git push origin :refs/tags/标签名 "},"git/0.0.3.html":{"url":"git/0.0.3.html","title":"肆.0.3 删除缓存的远程分支列表","keywords":"","body":"删除缓存的远程分支列表 git remote prune origin "},"glob/0.0.0.html":{"url":"glob/0.0.0.html","title":"拾.0.0 glob 介绍","keywords":"","body":"前端工程化~强大的glob语法 glob 在正则出现之前就有了，主要用于匹配文件路径，例如大名鼎鼎的 gulp 就使用了 glob 规则来匹配、查找并处理各种后缀的文件。在前端工程化的过程中，不可避免地会用 Node.js 来读取文件，例如想找到 src 目录下所有 js 和 jsx 文件，代码应该怎么写呢？首先安装依赖包： yarn add glob 然后 3 行代码搞定： const glob = require('glob') const files = glob.sync('src/**/*.js{,x}') console.log(files) 有没有感觉很强大呢？更重要的是 glob 语法在命令行就支持，不需要安装任何依赖，例如老板让你创建 a1.js 到 a9.js、b1.js 到 b9.js 这 18 个测试文件的话，怎么操作？一个个创建的话太傻了，glob 一句话就搞定： $ touch {a,b}{1..9}.js $ ls a1.js a3.js a5.js a7.js a9.js b2.js b4.js b6.js b8.js a2.js a4.js a6.js a8.js b1.js b3.js b5.js b7.js b9.js 更更更重要的是，glob 的语法非常简单，只要记住下面7个符号代表的含义就能掌握了： 基础语法：/、*、?、[] 拓展语法：**、{}、() 接下来就逐个解释一下： 基础语法 分隔符和片段 概念：分隔符是/，通过split('/') 得到的数组每一项是片段。 示例： src/index.js 有两个片段，分别是 src 和 index.js src/**/*.js 有三个片段，分别是 src、** 和 *.js 单个星号 概念：单个星号 * 用于匹配单个片段中的零个或多个字符。 示例： src/*.js 表示 src 目录下所有以 js 结尾的文件，但是不能匹配 src 子目录中的文件，例如 src/login/login.js /home/*/.bashrc 匹配所有用户的 .bashrc 文件 需要注意的是，* 不能匹配分隔符/，也就是说不能跨片段匹配字符。 问号 概念：问号 ? 匹配单个片段中的单个字符。 示例： test/?at.js 匹配形如 test/cat.js、test/bat.js 等所有3个字符且后两位是 at 的 js 文件，但是不能匹配 test/flat.js src/index.?? 匹配 src 目录下以 index 打头，后缀名是两个字符的文件，例如可以匹配 src/index.js 和 src/index.md，但不能匹配 src/index.jsx 中括号 概念:同样是匹配单个片段中的单个字符，但是字符集只能从括号内选择，如果字符集内有-，表示范围。 示例： test/[bc]at.js 只能匹配 test/bat.js 和 test/cat.js test/[c-f]at.js 能匹配 test/cat.js、test/dat.js、test/eat.js 和 test/fat.js 惊叹号 概念：表示取反，即排除那些去掉惊叹号之后能够匹配到的文件。 示例： test/[!bc]at.js不能匹配 test/bat.js 和 test/cat.js，但是可以匹配 test/fat.js !test/tmp/**' 排除 test/tmp 目录下的所有目录和文件 扩展语法 基础语法非常简单好记，但是功能非常局限，为了丰富 glob 的功能，衍生了下面三种扩展语法： 两个星号 概念：两个星号 ** 可以跨片段匹配零个或多个字符，也就是说**是递归匹配所有文件和目录的，如果后面有分隔符，即 **/ 的话，则表示只递归匹配所有目录（不含隐藏目录）。 示例： /var/log/** 匹配 /var/log 目录下所有文件和文件夹，以及文件夹里面所有子文件和子文件夹 /var/log/**/*.log 匹配 /var/log 及其子目录下的所有以 .log 结尾的文件 /home/*/.ssh/**/*.key 匹配所有用户的 .ssh 目录及其子目录内的以 .key 结尾的文件 大括号 概念：匹配大括号内的所有模式，模式之间用逗号进行分隔，支持大括号嵌套，支持用 .. 匹配连续的字符，即 {start..end} 语法。 示例： a.{png,jp{,e}g} 匹配 a.png、a.jpg、a.jpeg {a..c}{1..2} 匹配 a1 a2 b1 b2 c1 c2 注意：{} 与 [] 有一个很重要的区别：如果匹配的文件不存在，[]会失去模式的功能，变成一个单纯的字符串，而 {} 依然可以展开。 小括号 概念：小括号必须跟在 ?、*、+、@、! 后面使用，且小括号里面的内容是一组以 | 分隔符的模式集合，例如：abc|a?c|ac*。 示例： ?(pattern|pattern|pattern)：匹配0次或1次给定的模式 *(pattern|pattern|pattern):匹配0次或多次给定的模式 +(pattern|pattern|pattern)：匹配1次或多次给定的模式 @(pattern|pattern|pattern)：严格匹配给定的模式 !(pattern|pattern|pattern)：匹配非给定的模式 应用场景 webpack 多页面应用自动打包配置 在一个 webpack 项目中，假如我们有多个入口，每个入口都有一个 index.html 模板和 index.js 文件，而且这个入口是动态变化的，不希望每增加一个入口就改 webpack.config.js 配置文件，应该怎么办呢？ 此时可以约定在 src 下面创建的文件夹，只要里面有 index.js，我们就把它当做一个入口文件进行打包： src ├── detail │ ├── index.html │ └── index.js ├── home │ ├── index.html │ └── index.js ├── login │ ├── index.html │ └── index.js ├── shop │ ├── index.html │ └── index.js 用 glob 很快就能写出下面的自动打包代码： const HtmlWebpackPlugin = require('html-webpack-plugin') const path = require('path') const glob = require('glob') // 动态生成 entry 和 html-webpack-plugin function getMpa() { const entry = {}, htmlPlugins = [] const files = glob.sync('src/*/index.js') files.forEach((file) => { const filename = file.split('/')[1] entry[filename] = path.join(__dirname, file) htmlPlugins.push( new HtmlWebpackPlugin({ template: path.join(__dirname, `src/${filename}/index.html`), filename: `${filename}.html`, chunks: [filename], }) ) }) return { entry, htmlPlugins } } const mpa = getMpa() // 动态的配置文件 module.exports = { entry: mpa.entry, output: { path: path.join(__dirname, 'dist'), filename: '[name]-[hash:6].js', }, plugins: [...mpa.htmlPlugins], } 这样，无论增加多少个入口，webpack.config.js 都不用变。 手写一个约定大于配置的 Node.js 框架 egg.js 是一款优秀的 Node.js 企业级开发框架，就应用了约定大于配置的思想，例如： 约定一个中间件是一个放置在 app/middleware 目录下的单独文件 约定了 app/router.js 文件用于统一所有路由规则 约定 Service 文件必须放在 app/service 目录，可以支持多级目录，访问的时候可以通过目录名级联访问 因为一个大规模的团队需要遵循一定的约束和约定，开发效率才更高，有了这些约定之后，我们就可以利用 glob 写出匹配规则，找到用户放到指定目录下的文件并进行动态加载了，一个最基础的 load 函数如下： function load(folder, options) { const extname = options.extname || '.{js,ts}' return glob.sync(require('path').join(folder, `./**/*.js`)).forEach((item) => require(item)) } 使用 glob，配合相应的规范，例如 RESTful，我们自己也能封装一个简易的、基于约定的 Node.js 框架了。 "},"glob/0.0.1.html":{"url":"glob/0.0.1.html","title":"拾.0.1 强大的 glob","keywords":"","body":""},"rollup/0.0.0.html":{"url":"rollup/0.0.0.html","title":"佰.0.0 rollup 介绍","keywords":"","body":"rollup介绍 rollup文档 中文文档：https://www.rollupjs.com/ 官方文档：https://rollupjs.org/ 官方文档：https://rollupjs.org/guide/zh/ rollup是什么? rollup是一个JavaScript模块打包器，可以将小块代码编译成大块复杂的代码。 rollup有什么优势?（竞争力） rollup最大的亮点就是Tree-shaking，即可以静态分析代码中的import，并排除任何未使用的代码。这允许我们架构于现有工具和模块之上，而不会增加额外的依赖或使项目的大小膨胀。如果用webpack做，虽然可以实现tree-shaking，但是需要自己配置并且打包出来的代码非常臃肿，所以对于库文件和UI组件，rollup更加适合。 rollup适用于什么情况（什么时候使用rollup）? 对于库文件和UI组件，rollup更加适合 "},"rollup/0.0.1.html":{"url":"rollup/0.0.1.html","title":"佰.0.1 rollup 基础","keywords":"","body":"rollup基础 1，创建项目文件夹 mkdir 2，进入项目文件夹 cd 3，初始化项目 npm init -y 4，安装rollup（开发依赖） npm i -D rollup 5，安装balel插件（开发依赖），用于代码转换 // @babel/core：babel插件核心功能 // @babel/preset-env：env预设，用于把es高版本转换为es5代码 // @rollup/plugin-babel：连接rollup与babel npm i -D @babel/core @babel/preset-env @rollup/plugin-babel 6，创建babel配置文件：babel.config.js | babel.config.json | .babelrc { } 7，安装js代码压缩插件：rollup-plugin-terser（开发依赖） // rollup-plugin-terser：压缩js代码，包括es6代码压缩 npm i -D rollup-plugin-terser 8，其他必装插件：rollup-plugin-node-resolve && rollup-plugin-commonjs（开发依赖） // rollup-plugin-commonjs：用来将 CommonJS 模块转换为 ES2015 供 rollup 处理 // rollup-plugin-node-resolve：告诉 Rollup 如何查找外部模块 npm i -D rollup-plugin-node-resolve rollup-plugin-commonjs 9，rollup配置文件：rollup.config.js import babel from '@rollup/plugin-babel' export default { input: './src/index.js', output: { file: 'dist/vue.js', format: 'umd', name: 'Vue', sourcemap: true }, plugins: [ babel({ exclude: 'node_modules/**' }) ] } "},"rollup/0.0.2.html":{"url":"rollup/0.0.2.html","title":"佰.0.2 rollup 打包格式","keywords":"","body":"rollup打包格式 文档：https://www.rollupjs.com/guide/big-list-of-options#%E6%A0%BC%E5%BC%8Fformat--f--outputformat AMD Asynchronous Module Definition，可以看作CJS的异步版本，制定了一套规则使模块可以被异步require进来并在回调函数里继续使用，然后require.js等前端库也可以利用这个规则加载代码了，目前已经是时代的眼泪了。 CJS CommonJS，只能在NodeJS上运行，使用require(\"module\")读取并加载模块。 缺点：不支持浏览器，执行后才能拿到依赖信息，由于用户可以动态require（例如react根据开发和生产环境导出不同代码的写法），无法做到提前分析依赖以及Tree-Shaking。 UMD Universal Module Definition，同时兼容CJS和AMD，并且支持直接在前端用的方式加载。现在还在广泛使用，不过可以想象ESM和IIFE逐渐代替它。 ESM ECMAScript Module，现在使用的模块方案，使用import export来管理依赖。由于它们只能写在所有表达式外面，所以打包器可以轻易做到分析依赖以及Tree-Shaking。当然他也支持动态加载import()。 浏览器直接通过即可使用该写法。NodeJS可以通过使用mjs后缀或者在package.json添加\"type\": \"module\"来使用，注意他还有一些实验性的功能没有正式开启。考虑到大量cjs库没有支持，如果要发布esm版的库还是通过rollup打包一下比较好（同时相关依赖可以放到devDependencies里）。 IIFE Immediately Invoked Function Expression，只是一种写法，可以隐藏一些局部变量，前端人要是不懂这个可能学的是假前端。可以用来代替UMD作为纯粹给前端使用的写法。 "},"rollup/0.0.3.html":{"url":"rollup/0.0.3.html","title":"佰.0.3 rollup 插件及使用","keywords":"","body":"rollup插件及使用 babel代码转译 // 安装依赖 npm i -D @babel/core @babel/preset-env @rollup/plugin-babel // 使用前置条件，配置babel.config.js | babel.config.json | .babelrc // babel.config.json { \"presets\": [ [ \"@babel/preset-env\", { \"useBuiltIns\": \"entry\" } ] ] } // babel.config.js module.exports = { \"presets\": [ [ \"@babel/preset-env\", { \"useBuiltIns\": \"entry\" } ] ] } // .babelrc { \"presets\": [ [ \"@babel/preset-env\", { \"useBuiltIns\": \"entry\" } ] ] } // 使用：rollup.config.js文件配置如下 import babel from \"@rollup/plugin-babel\" export default { \"plugins\": [ babel({ exclude: 'node_modules/**' }) ] } 代码压缩：rollup-plugin-terser // 安装 npm i -D rollup-plugin-terser // 配置 import { terser } from \"rollup-plugin-terser\"; import babel from \"@rollup/plugin-babel\" export default { \"plugins\": [ babel({ exclude: 'node_modules/**' }), terser() ] } @rollup/plugin-node-resolve // 安装 yarn add -D @rollup/plugin-node-resolve // 配置 import { nodeResolve } from \"@@rollup/plugin-node-resolve\"; import { terser } from \"rollup-plugin-terser\"; import babel from \"@rollup/plugin-babel\" export default { \"plugins\": [ nodeResolve(), babel({ exclude: 'node_modules/**' }), terser() ] } "},"rollup/0.0.4.html":{"url":"rollup/0.0.4.html","title":"佰.0.4 rollup 配置文件内容","keywords":"","body":"rollup配置文件内容 安装依赖 npm i -D rollup npm i -D @bebal/core @babel/preset-env @rollup/plugin-babel npm i -D @rollup/plugin-commonjs @rollup/plugin-node-resolve npm i -D rollup-plugin-terser 配置内容（rollup.config.js） import commonjs from '@rollup/plugin-commonjs' import { nodeResolve } from \"@rollup/plugin-node-resolve\"; import { terser } from \"rollup-plugin-terser\"; import babel from \"@rollup/plugin-babel\" export default { \"input\": \"./src/index.js\", \"output\": { file: \"./dist/bundle.js\", format: \"UMD\", name: \"bundle\", sourcemap: true }, \"plugins\": [ commonjs(), nodeResolve(), babel({ exclude: 'node_modules/**' }), terser() ] } "},"vite/0.0.0.html":{"url":"vite/0.0.0.html","title":"千.0.0 vite 介绍","keywords":"","body":"vite 官方文档：https://vitejs.dev/ 官方中文文档：https://cn.vitejs.dev/ 特性 1，极速的服务启动：完全类型化的API 2，轻量快速的热重载：无论应用程序大小如何，都始终极快的模块热重载（HMR） 3，丰富的功能：对TypeScript、JSX、CSS等支持开箱即用。 4，优化的构建：可选 “多页应用” 或 “库” 模式的预配置Rollup构建 5，通用的插件：在开发和构建之间共享Rollup-superset插件接口。 6，完全类型化的API：灵活的API和完整的TypeScript类型。 为什么选Vite 官方说明：https://cn.vitejs.dev/guide/why.html "},"vite/0.0.1.html":{"url":"vite/0.0.1.html","title":"千.0.1 使用 vite 创建 vue3+ts 项目","keywords":"","body":"使用 vite创建 vue3+ts项目 创建项目 // 格式： yarn create vite --template vue-ts yarn create vite myapp --template vue-ts 安装依赖 yarn 启动项目 yarn dev 集成 vue-router 1，安装 yarn add vue-router 2，创建 src/router/router.ts文件，内容如下 import { createRouter, createWebHistory } from 'vue-router' const routes = [ { path: '/', name: 'index', component: () => import('../pages/index.vue') }, { path: '/list', name: 'list', component: () => import('../pages/list.vue') } ] const router = createRouter({ history: createWebHistory(), routes }) export default router 3，在 main.ts文件中引入 router.js文件，main.ts内容如下： import { createApp } from 'vue' import router from './router/router' import App from './App.vue' createApp(App).use(router).mount('#app') 集成 vuex 1，安装 yarn add vuex 2，创建 src/store/store.ts文件，内容如下 import { createStore } from 'vuex' const store = createStore({ state: { count: 1 }, mutations: { SET_COUNT(state){ state.count += 1 } } }) export default store 3，修改 main.ts内容如下： import { createApp } from 'vue' import router from './router/router' import store from './store/store' import App from './App.vue' createApp(App).use(router).use(store).mount('#app') 4，组件内使用 + import { useStore } from 'vuex' const store = useStore() 集成 sass 安装 sass即可 yarn add sass -D 集成 axios yarn add axios 使用@代替src 1，在vite.config.js配置文件中增加resolve.alias配置，如下 import { defineConfig } from \"vite\"; import vue from \"@vitejs/plugin-vue\"; export default defineConfig({ plugins: [vue()], // 增加resolve.alias配置 // 此操作后有，项目已经支持了，但是ts依然会飘红，处理方法在下面 resolve: { alias: { \"@\": \"/src\", }, }, }); 2，处理ts飘红：修改项目根目录下的tsconfig.json文件，增加compilerOptions.baseUrl和compilerOptions.paths配置字段 { compilerOptions: { \"baseUrl\": \"./\", \"paths\": { \"@/*\": [\"src/*\"] } } } "},"vite/0.0.2.html":{"url":"vite/0.0.2.html","title":"千.0.2 vue2 中使用 vite","keywords":"","body":"vue2中使用vite (壹)、初始化项目 yarn create vite ? Select a framework: vanilla (这个地方选择原生，选vue的话默认vue3.0) (贰)、安装插件 yarn add vite-plugin-vue2 -D (叁)、创建配置文件：vite.config.js import { createVuePlugin } from 'vite-plugin-vue2' export default { plugins: [createVuePlugin()] } (肆)、安装vue(需指定版本) && vue-template-compiler yarn add vue@2.6.14 vue-template-compiler (伍)、修改目录 && 文件 1，根目录新建src文件夹，并把根目录下的main.js文件移到src目录下，main.js的内容如下 import Vue from 'vue' import App from './App.vue' new Vue({ render: h => h(App) }).$mount('#app') 2，src目录下创建App.vue文件，App.vue的内容如下： Hello Vite Vue2 3，index.html文件中引入的main.js路径变为如下： (陸)、启动项目 yarn dev (柒)、集成vue-router路由(需指定3.x.x版本) 1，安装vue-router yarn add vue-router@3.5.3 2，创建路由文件(src/router/router.js)，并配置路由信息 // src/router/router.js import Vue from 'vue' import Router from \"vue-router\"; Vue.use(Router) const routes = [ { path: \"/login\", name: \"login\", component: () => import(\"../pages/login.vue\"), }, { path: \"/list\", name: \"list\", component: () => import(\"../pages/list.vue\"), }, ] const router = new Router({ mode: 'history', routes }); export default router; 3，main.js文件内容修改如下 import Vue from 'vue' import router from './router/router.js' import App from './App.vue' new Vue({ router, render: h => h(App) }).$mount('#app') (捌)、集成vuex(需指定版本)状态管理 1，安装vuex，版本为3.x.x yarn add vuex@3.6.2 2，创建store.js文件(src/store/store.js)，并配置相关内容 import Vue from \"vue\"; import Vuex from \"vuex\"; Vue.use(Vuex); export default new Vuex.Store({ state: { count: 0, }, //同步方法 mutations: { SET_COUNT(state) { state.count += 1 }, }, }); 3，main.js文件内容修改如下 import Vue from 'vue' import router from './router/router.js' import store from './store/store.js' import App from './App.vue' new Vue({ store, router, render: h => h(App) }).$mount('#app') (玖)、集成axios发送请求 1，安装axios yarn add axios 2，配置，修改main.js如下： import Vue from 'vue' import router from './router/router.js' import store from './store/store.js' import axios from 'axios' import App from './App.vue' Vue.prototype.$axios = axios new Vue({ store, router, render: h => h(App) }).$mount('#app') 3，使用 export default { methods: { async getList() { const res = await this.$axios.get(\"/mock/getList.json\"); console.log(res.data.data); } } } (拾)、sass支持 Vite 也同时提供了对 .scss, .sass, .less, .styl 和 .stylus 文件的内置支持，只需安装相应的预处理器依赖 文档：https://cn.vitejs.dev/guide/features.html#css-pre-processors yarn add sass -D "},"vite/0.0.3.html":{"url":"vite/0.0.3.html","title":"千.0.3 集成 eslint && prettier","keywords":"","body":"集成 eslint && prettier eslint 是做什么的? eslint 用来制定代码书写规范，并检测书写的代码是否符合制定的代码规范 eslint 可以针对不符合规范的代码进行部分修复--fix prettire 是做什么的 prettier(code formatter) 用来按照指定的规范去格式化书写的代码 集成 eslint eslint 分为 npm 包和 vs code 插件 npm 包只有主动使用命令校验才会检查代码是否符合规范，因此 vs code 中才会有 eslint 插件，用来实时检验代码是否符合规范 并且 eslint 的修复功能也要在保存代码时自动修复 "},"senior/0.0.0.html":{"url":"senior/0.0.0.html","title":"亿.0.0 数据响应式原理","keywords":"","body":"数据响应式原理 "},"senior/0.0.1.html":{"url":"senior/0.0.1.html","title":"亿.0.1 双向数据绑定原理","keywords":"","body":"双向数据绑定原理 "},"senior/0.0.2.html":{"url":"senior/0.0.2.html","title":"亿.0.2 MVVM 原理","keywords":"","body":"MVVM原理 "},"senior/0.0.3.html":{"url":"senior/0.0.3.html","title":"亿.0.3 实现虚拟 DOM","keywords":"","body":"实现虚拟DOM 最近一两年前端最火的技术莫过于ReactJS，即便你没用过也该听过，ReactJS由业界顶尖的互联网公司facebook提出，其本身有很多先进的设计思路，比如页面UI组件化、虚拟DOM等。本文将带你解开虚拟DOM的神秘面纱，不仅要理解其原理，而且要实现一个基本可用的虚拟DOM。 1.为什么需要虚拟DOM DOM是很慢的，其元素非常庞大，页面的性能问题鲜有由JS引起的，大部分都是由DOM操作引起的。如果对前端工作进行抽象的话，主要就是维护状态和更新视图；而更新视图和维护状态都需要DOM操作。其实近年来，前端的框架主要发展方向就是解放DOM操作的复杂性。 在jQuery出现以前，我们直接操作DOM结构，这种方法复杂度高，兼容性也较差；有了jQuery强大的选择器以及高度封装的API，我们可以更方便的操作DOM，jQuery帮我们处理兼容性问题，同时也使DOM操作变得简单；但是聪明的程序员不可能满足于此，各种MVVM框架应运而生，有angularJS、avalon、vue.js等，MVVM使用数据双向绑定，使得我们完全不需要操作DOM了，更新了状态视图会自动更新，更新了视图数据状态也会自动更新，可以说MMVM使得前端的开发效率大幅提升，但是其大量的事件绑定使得其在复杂场景下的执行性能堪忧；有没有一种兼顾开发效率和执行效率的方案呢？ReactJS就是一种不错的方案，虽然其将JS代码和HTML代码混合在一起的设计有不少争议，但是其引入的Virtual DOM(虚拟DOM)却是得到大家的一致认同的。 2.理解虚拟DOM 虚拟的DOM的核心思想是：对复杂的文档DOM结构，提供一种方便的工具，进行最小化地DOM操作。这句话，也许过于抽象，却基本概况了虚拟DOM的设计思想 (1) 提供一种方便的工具，使得开发效率得到保证 (2) 保证最小化的DOM操作，使得执行效率得到保证 (1).用JS表示DOM结构 DOM很慢，而javascript很快，用javascript对象可以很容易地表示DOM节点。DOM节点包括标签、属性和子节点，通过VElement表示如下。 //虚拟dom，参数分别为标签名、属性对象、子DOM列表 var VElement = function(tagName, props, children) { //保证只能通过如下方式调用：new VElement if (!(this instanceof VElement)) { return new VElement(tagName, props, children); } //可以通过只传递tagName和children参数 if (util.isArray(props)) { children = props; props = {}; } //设置虚拟dom的相关属性 this.tagName = tagName; this.props = props || {}; this.children = children || []; this.key = props ? props.key : void 666; var count = 0; util.each(this.children, function(child, i) { if (child instanceof VElement) { count += child.count; } else { children[i] = '' + child; } count++; }); this.count = count; } 通过VElement，我们可以很简单地用javascript表示DOM结构。比如 var vdom = velement('div', { 'id': 'container' }, [ velement('h1', { style: 'color:red' }, ['simple virtual dom']), velement('p', ['hello world']), velement('ul', [velement('li', ['item #1']), velement('li', ['item #2'])]), ]); 上面的javascript代码可以表示如下DOM结构： simple virtual dom hello world item #1 item #2 同样我们可以很方便地根据虚拟DOM树构建出真实的DOM树。具体思路：根据虚拟DOM节点的属性和子节点递归地构建出真实的DOM树。见如下代码： VElement.prototype.render = function() { //创建标签 var el = document.createElement(this.tagName); //设置标签的属性 var props = this.props; for (var propName in props) { var propValue = props[propName] util.setAttr(el, propName, propValue); } //依次创建子节点的标签 util.each(this.children, function(child) { //如果子节点仍然为velement，则递归的创建子节点，否则直接创建文本类型节点 var childEl = (child instanceof VElement) ? child.render() : document.createTextNode(child); el.appendChild(childEl); }); return el; } 对一个虚拟的DOM对象VElement，调用其原型的render方法，就可以产生一颗真实的DOM树。 vdom.render(); 既然我们可以用JS对象表示DOM结构，那么当数据状态发生变化而需要改变DOM结构时，我们先通过JS对象表示的虚拟DOM计算出实际DOM需要做的最小变动，然后再操作实际DOM，从而避免了粗放式的DOM操作带来的性能问题。 (2).比较两棵虚拟DOM树的差异 在用JS对象表示DOM结构后，当页面状态发生变化而需要操作DOM时，我们可以先通过虚拟DOM计算出对真实DOM的最小修改量，然后再修改真实DOM结构(因为真实DOM的操作代价太大)。 如下图所示，两个虚拟DOM之间的差异已经标红： 为了便于说明问题，我当然选取了最简单的DOM结构，两个简单DOM之间的差异似乎是显而易见的，但是真实场景下的DOM结构很复杂，我们必须借助于一个有效的DOM树比较算法。 设计一个diff算法有两个要点： 如何比较两个两棵DOM树 如何记录节点之间的差异 如何比较两个两棵DOM树 计算两棵树之间差异的常规算法复杂度为O(n3)，一个文档的DOM结构有上百个节点是很正常的情况，这种复杂度无法应用于实际项目。针对前端的具体情况：我们很少跨级别的修改DOM节点，通常是修改节点的属性、调整子节点的顺序、添加子节点等。因此，我们只需要对同级别节点进行比较，避免了diff算法的复杂性。对同级别节点进行比较的常用方法是深度优先遍历： function diff(oldTree, newTree) { //节点的遍历顺序 var index = 0; //在遍历过程中记录节点的差异 var patches = {}; //深度优先遍历两棵树 dfsWalk(oldTree, newTree, index, patches); return patches; } 如何记录节点之间的差异 由于我们对DOM树采取的是同级比较，因此节点之间的差异可以归结为4种类型： 修改节点属性, 用PROPS表示 修改节点文本内容, 用TEXT表示 替换原有节点, 用REPLACE表示 调整子节点，包括移动、删除等，用REORDER表示 对于节点之间的差异，我们可以很方便地使用上述四种方式进行记录，比如当旧节点被替换时： {type:REPLACE,node:newNode} 而当旧节点的属性被修改时： {type:PROPS,props: newProps} 在深度优先遍历的过程中，每个节点都有一个编号，如果对应的节点有变化，只需要把相应变化的类别记录下来即可。下面是具体实现： function dfsWalk(oldNode, newNode, index, patches) { var currentPatch = []; if (newNode === null) { //依赖listdiff算法进行标记为删除 } else if (util.isString(oldNode) && util.isString(newNode)) { if (oldNode !== newNode) { //如果是文本节点则直接替换文本 currentPatch.push({ type: patch.TEXT, content: newNode }); } } else if (oldNode.tagName === newNode.tagName && oldNode.key === newNode.key) { //节点类型相同 //比较节点的属性是否相同 var propsPatches = diffProps(oldNode, newNode); if (propsPatches) { currentPatch.push({ type: patch.PROPS, props: propsPatches }); } //比较子节点是否相同 diffChildren(oldNode.children, newNode.children, index, patches, currentPatch); } else { //节点的类型不同，直接替换 currentPatch.push({ type: patch.REPLACE, node: newNode }); } if (currentPatch.length) { patches[index] = currentPatch; } } 比如对上文图中的两颗虚拟DOM树，可以用如下数据结构记录它们之间的变化： var patches = { 1:{type:REPLACE,node:newNode}, //h1节点变成h5 5:{type:REORDER,moves:changObj} //ul新增了子节点li } (3).对真实DOM进行最小化修改 通过虚拟DOM计算出两颗真实DOM树之间的差异后，我们就可以修改真实的DOM结构了。上文深度优先遍历过程产生了用于记录两棵树之间差异的数据结构patches, 通过使用patches我们可以方便对真实DOM做最小化的修改。 //将差异应用到真实DOM function applyPatches(node, currentPatches) { util.each(currentPatches, function(currentPatch) { switch (currentPatch.type) { //当修改类型为REPLACE时 case REPLACE: var newNode = (typeof currentPatch.node === 'String') ? document.createTextNode(currentPatch.node) : currentPatch.node.render(); node.parentNode.replaceChild(newNode, node); break; //当修改类型为REORDER时 case REORDER: reoderChildren(node, currentPatch.moves); break; //当修改类型为PROPS时 case PROPS: setProps(node, currentPatch.props); break; //当修改类型为TEXT时 case TEXT: if (node.textContent) { node.textContent = currentPatch.content; } else { node.nodeValue = currentPatch.content; } break; default: throw new Error('Unknow patch type ' + currentPatch.type); } }); } 至此，虚拟DOM的基本原理已经基本讲解完成了；我们也一起实现了一个基本可用的虚拟DOM。 "}}