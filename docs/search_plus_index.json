{"./":{"url":"./","title":"前言.写给有缘人","keywords":"","body":"前言·写给有缘人 01.codeing到80岁 作为一个老程序员，codeing已经成为生命的一部分，coding到八十岁是我的理想，而JavaScript是我挚爱的语言！ 自从2010年出版个人第一本互联网技术书籍后，便再也没有时间可以写系统性论述技术的著作。因为后来加入奇虎360和百度这两家一线互联网公司，从事前端与手机客户端技术性工作，并主持研发了亿级用户的手机APP，这期间相当繁忙。 在接受了一线互联网企业的再锻造与重塑之后，编程工作就像打游戏一样，让我觉得快乐与充实。每天都能“通关”，解决掉一个又一个问题，与优秀的聪明的睿智的热心的同事们一起协同合作，创造一个又一个生动有趣的产品，成就感是满满的……而且最重要的，在这个过程中居然还能赚到不少钱，让我作为一个程序员能够体面地生活并做自己喜欢的事，这实在是太美妙了！ "},"gitbook/0.0.0.html":{"url":"gitbook/0.0.0.html","title":"零.0.0 从零开始使用gitbook搭建文档站点","keywords":"","body":"从零开始使用gitbook搭建文档站点 安装gitbook-cli脚手架工具 npm i -g gitbook-cli 查看安装版本 gitbook --version gitbook -V 初始化项目 // 执行如下命令会在当前目录下生成2个文件（README.md && SUMMARY.md） gitbook init // 执行如下命令会在当前的note文件夹下生产2个文件（README.md && SUMMARY.md） // 如果没有note文件夹，会先创建note文件夹 git init ./note 注意1：执行gitbook init命令如果报如下错误： Installing GitBook 3.2.3 SOLINK_MODULE(target) Release/.node CXX(target) Release/obj.target/fse/fsevents.o SOLINK_MODULE(target) Release/fse.node SOLINK_MODULE(target) Release/.node CXX(target) Release/obj.target/fse/fsevents.o SOLINK_MODULE(target) Release/fse.node /usr/local/lib/node_modules/gitbook-cli/node_modules/npm/node_modules/graceful-fs/polyfills.js:287 if (cb) cb.apply(this, arguments) ^ TypeError: cb.apply is not a function at /usr/local/lib/node_modules/gitbook-cli/node_modules/npm/node_modules/graceful-fs/polyfills.js:287:18 at FSReqCallback.oncomplete (fs.js:184:5) 关键信息 TypeError: cb.apply is not a function at /usr/local/lib/node_modules/gitbook-cli/node_modules/npm/node_modules/graceful-fs/polyfills.js:287:18 解决方法：修改polyfills.js文件内容，注释一下三行内容（62行左右） // fs.stat = statFix(fs.stat) // fs.fstat = statFix(fs.fstat) // fs.lstat = statFix(fs.lstat) 注意2：执行gitbook init命令如果报如下错误： 原因：node版本太高，进行降级处理或者不处理此报错，手动创建SUMMARY.md文件 warn: no summary file in this book info: create README.md info: create SUMMARY.md TypeError [ERR_INVALID_ARG_TYPE]: The \"data\" argument must be of type string or an instance of Buffer, TypedArray, or DataView. Received an instance of Promise 启动项目（本地服务器） gitbook serve 打包项目 gitbook build SUMMARY.md书写格式如下 # Summary * [前言.写给有缘人](README.md) ### 零、GITBOOK * [零.0.0 从零开始使用gitbook搭建文档站点](0/0.0.0.md) * [零.0.1 gitbook插件集合](0/0.0.1.md) ### 佰、ROLLUP * [佰.0.0 rollup介绍](100/100.0.0.md) * [佰.0.1 rollup基础](100/100.0.1.md) gitbook之配置文件book.json // root：配置README.md && SUMMARY.md的位置 { \"root\": \"./docs\", \"title\": \"codeing\", \"description\": \"codeing...\", \"language\": \"zh-hans\", \"@styles\": { \"website\": \"./styles/website.css\" }, \"@links\": { \"sidebar\": { \"知乎\": \"https://www.zhihu.com/people/codeing.cn\", \"gitbook\": \"https://zhuanlan.zhihu.com/p/34946169\", \"前端内参\": \"https://coffe1891.gitbook.io\", \"如何学习\": \"https://juejin.cn/post/6960892566921281543\" } }, \"plugins\": [ \"-search\", \"search-pro\" ] } "},"gitbook/0.0.1.html":{"url":"gitbook/0.0.1.html","title":"零.0.1 gitbook插件集合","keywords":"","body":"GITBOOK插件集合 介绍一下gitbook中book.json的一些实用配置和插件 全局配置 title 设置本书的标题（书名） \"title\": \"前端系列文章\" author 本书的作者的相关信息 \"author\": \"codeing.cn\" description 本书的简单描述 \"description\": \"记录与分享前端相关技术系列文章\" language 配置本书使用的语言 // 配置使用简体中文 \"language\": \"zh-hans\" links 配置在左侧导航栏的链接 \"links\": { \"sidebar\": { \"Home\": \"https://www.zhihu.com/people/codeing.cn\" } } styles 自定义页面样式，默认情况下各generator对应的css文件如下 \"styles\": { \"website\": \"styles/website.css\", \"ebook\": \"styles/ebook.css\", \"pdf\": \"styles/pdf.css\", \"mobi\": \"styles/mobi.css\", \"epub\": \"styles/epub.css\" } 例如使 标签有下边框， 可以在website.css中设置 h1 , h2{ border-bottom: 1px solid #EFEAEA; } 插件相关 plugins 配置使用的插件 \"plugins\": [ \"-search\", \"back-to-top-button\", \"expandable-chapters-small\", \"insert-logo\" ] 其中\"-search\"中的 - 符号代表去除默认自带的插件 // Gitbook默认自带有5个插件: highlight // 代码高亮 search // 导航栏查询功能（不支持中文） sharing // 右上角分享功能 font-settings // 字体设置（最上方的\"A\"符号） livereload // 为GitBook实时重新加载 pluginsConfig 配置插件的属性 // 配置insert-logo的属性 \"pluginsConfig\": { \"insert-logo\": { \"url\": \"images/logo.png\", \"style\": \"background: none; max-height: 30px; min-height: 30px\" } } "},"vscode/0.0.0.html":{"url":"vscode/0.0.0.html","title":"零.0.0 前端必装插件","keywords":"","body":"前端必装插件 chinese language pack for ... debugger for chrome auto close tag auto rename tag live server // 启动本地服务 open in browser power mode // 编码光标显示特效 svg preview // svg预览 prettier - code formatter vetur // vue2开发必装 volar // vue3开发必装 vscode-icons // vscode文件&文件夹图标 eslint git graph // git commit 记录查看 "},"glob/0.0.0.html":{"url":"glob/0.0.0.html","title":"拾.0.0 glob介绍","keywords":"","body":""},"glob/0.0.1.html":{"url":"glob/0.0.1.html","title":"拾.0.1 强大的glob","keywords":"","body":""},"rollup/0.0.0.html":{"url":"rollup/0.0.0.html","title":"佰.0.0 rollup介绍","keywords":"","body":"rollup介绍 rollup文档 中文文档：https://www.rollupjs.com/ 官方文档：https://rollupjs.org/ 官方文档：https://rollupjs.org/guide/zh/ rollup是什么? rollup是一个JavaScript模块打包器，可以将小块代码编译成大块复杂的代码。 rollup有什么优势?（竞争力） rollup最大的亮点就是Tree-shaking，即可以静态分析代码中的import，并排除任何未使用的代码。这允许我们架构于现有工具和模块之上，而不会增加额外的依赖或使项目的大小膨胀。如果用webpack做，虽然可以实现tree-shaking，但是需要自己配置并且打包出来的代码非常臃肿，所以对于库文件和UI组件，rollup更加适合。 rollup适用于什么情况（什么时候使用rollup）? 对于库文件和UI组件，rollup更加适合 "},"rollup/0.0.1.html":{"url":"rollup/0.0.1.html","title":"佰.0.1 rollup基础","keywords":"","body":"rollup基础 1，创建项目文件夹 mkdir 2，进入项目文件夹 cd 3，初始化项目 npm init -y 4，安装rollup（开发依赖） npm i -D rollup 5，安装balel插件（开发依赖），用于代码转换 // @babel/core：babel插件核心功能 // @babel/preset-env：env预设，用于把es高版本转换为es5代码 // @rollup/plugin-babel：连接rollup与babel npm i -D @babel/core @babel/preset-env @rollup/plugin-babel 6，创建babel配置文件：babel.config.js | babel.config.json | .babelrc { } 7，安装js代码压缩插件：rollup-plugin-terser（开发依赖） // rollup-plugin-terser：压缩js代码，包括es6代码压缩 npm i -D rollup-plugin-terser 8，其他必装插件：rollup-plugin-node-resolve && rollup-plugin-commonjs（开发依赖） // rollup-plugin-commonjs：用来将 CommonJS 模块转换为 ES2015 供 rollup 处理 // rollup-plugin-node-resolve：告诉 Rollup 如何查找外部模块 npm i -D rollup-plugin-node-resolve rollup-plugin-commonjs 9，rollup配置文件：rollup.config.js import babel from '@rollup/plugin-babel' export default { input: './src/index.js', output: { file: 'dist/vue.js', format: 'umd', name: 'Vue', sourcemap: true }, plugins: [ babel({ exclude: 'node_modules/**' }) ] } "},"rollup/0.0.2.html":{"url":"rollup/0.0.2.html","title":"佰.0.2 rollup打包格式","keywords":"","body":"rollup打包格式 文档：https://www.rollupjs.com/guide/big-list-of-options#%E6%A0%BC%E5%BC%8Fformat--f--outputformat AMD Asynchronous Module Definition，可以看作CJS的异步版本，制定了一套规则使模块可以被异步require进来并在回调函数里继续使用，然后require.js等前端库也可以利用这个规则加载代码了，目前已经是时代的眼泪了。 CJS CommonJS，只能在NodeJS上运行，使用require(\"module\")读取并加载模块。 缺点：不支持浏览器，执行后才能拿到依赖信息，由于用户可以动态require（例如react根据开发和生产环境导出不同代码的写法），无法做到提前分析依赖以及Tree-Shaking。 UMD Universal Module Definition，同时兼容CJS和AMD，并且支持直接在前端用的方式加载。现在还在广泛使用，不过可以想象ESM和IIFE逐渐代替它。 ESM ECMAScript Module，现在使用的模块方案，使用import export来管理依赖。由于它们只能写在所有表达式外面，所以打包器可以轻易做到分析依赖以及Tree-Shaking。当然他也支持动态加载import()。 浏览器直接通过即可使用该写法。NodeJS可以通过使用mjs后缀或者在package.json添加\"type\": \"module\"来使用，注意他还有一些实验性的功能没有正式开启。考虑到大量cjs库没有支持，如果要发布esm版的库还是通过rollup打包一下比较好（同时相关依赖可以放到devDependencies里）。 IIFE Immediately Invoked Function Expression，只是一种写法，可以隐藏一些局部变量，前端人要是不懂这个可能学的是假前端。可以用来代替UMD作为纯粹给前端使用的写法。 "},"rollup/0.0.3.html":{"url":"rollup/0.0.3.html","title":"佰.0.3 rollup插件及使用","keywords":"","body":"rollup插件及使用 babel代码转译 // 安装依赖 npm i -D @babel/core @babel/preset-env @rollup/plugin-babel // 使用前置条件，配置babel.config.js | babel.config.json | .babelrc // babel.config.json { \"presets\": [ [ \"@babel/preset-env\", { \"useBuiltIns\": \"entry\" } ] ] } // babel.config.js module.exports = { \"presets\": [ [ \"@babel/preset-env\", { \"useBuiltIns\": \"entry\" } ] ] } // .babelrc { \"presets\": [ [ \"@babel/preset-env\", { \"useBuiltIns\": \"entry\" } ] ] } // 使用：rollup.config.js文件配置如下 import babel from \"@rollup/plugin-babel\" export default { \"plugins\": [ babel({ exclude: 'node_modules/**' }) ] } 代码压缩：rollup-plugin-terser // 安装 npm i -D rollup-plugin-terser // 配置 import { terser } from \"rollup-plugin-terser\"; import babel from \"@rollup/plugin-babel\" export default { \"plugins\": [ babel({ exclude: 'node_modules/**' }), terser() ] } @rollup/plugin-node-resolve // 安装 yarn add -D @rollup/plugin-node-resolve // 配置 import { nodeResolve } from \"@@rollup/plugin-node-resolve\"; import { terser } from \"rollup-plugin-terser\"; import babel from \"@rollup/plugin-babel\" export default { \"plugins\": [ nodeResolve(), babel({ exclude: 'node_modules/**' }), terser() ] } "},"rollup/0.0.4.html":{"url":"rollup/0.0.4.html","title":"佰.0.4 rollup配置文件内容","keywords":"","body":"rollup配置文件内容 安装依赖 npm i -D rollup npm i -D @bebal/core @babel/preset-env @rollup/plugin-babel npm i -D @rollup/plugin-commonjs @rollup/plugin-node-resolve npm i -D rollup-plugin-terser 配置内容（rollup.config.js） import commonjs from '@rollup/plugin-commonjs' import { nodeResolve } from \"@rollup/plugin-node-resolve\"; import { terser } from \"rollup-plugin-terser\"; import babel from \"@rollup/plugin-babel\" export default { \"input\": \"./src/index.js\", \"output\": { file: \"./dist/bundle.js\", format: \"UMD\", name: \"bundle\", sourcemap: true }, \"plugins\": [ commonjs(), nodeResolve(), babel({ exclude: 'node_modules/**' }), terser() ] } "},"vite/0.0.0.html":{"url":"vite/0.0.0.html","title":"千.0.0 vite介绍","keywords":"","body":"vite 官方文档：https://vitejs.dev/ 官方中文文档：https://cn.vitejs.dev/ 特性 1，极速的服务启动：完全类型化的API 2，轻量快速的热重载：无论应用程序大小如何，都始终极快的模块热重载（HMR） 3，丰富的功能：对TypeScript、JSX、CSS等支持开箱即用。 4，优化的构建：可选 “多页应用” 或 “库” 模式的预配置Rollup构建 5，通用的插件：在开发和构建之间共享Rollup-superset插件接口。 6，完全类型化的API：灵活的API和完整的TypeScript类型。 为什么选Vite 官方说明：https://cn.vitejs.dev/guide/why.html "},"vite/0.0.1.html":{"url":"vite/0.0.1.html","title":"千.0.1 使用vite创建vue3+ts项目","keywords":"","body":"使用 vite创建 vue3+ts项目 创建项目 // 格式： yarn create vite --template vue-ts yarn create vite myapp --template vue-ts 安装依赖 yarn 启动项目 yarn dev 集成 vue-router 1，安装 yarn add vue-router 2，创建 src/router/router.ts文件，内容如下 import { createRouter, createWebHistory } from 'vue-router' const routes = [ { path: '/', name: 'index', component: () => import('../pages/index.vue') }, { path: '/list', name: 'list', component: () => import('../pages/list.vue') } ] const router = createRouter({ history: createWebHistory(), routes }) export default router 3，在 main.ts文件中引入 router.js文件，main.ts内容如下： import { createApp } from 'vue' import router from './router/router' import App from './App.vue' createApp(App).use(router).mount('#app') 集成 vuex 1，安装 yarn add vuex 2，创建 src/store/store.ts文件，内容如下 import { createStore } from 'vuex' const store = createStore({ state: { count: 1 }, mutations: { SET_COUNT(state){ state.count += 1 } } }) export default store 3，修改 main.ts内容如下： import { createApp } from 'vue' import router from './router/router' import store from './store/store' import App from './App.vue' createApp(App).use(router).use(store).mount('#app') 4，组件内使用 + import { useStore } from 'vuex' const store = useStore() 集成 sass 安装 sass即可 yarn add sass -D 集成 axios yarn add axios 使用@代替src 1，在vite.config.js配置文件中增加resolve.alias配置，如下 import { defineConfig } from \"vite\"; import vue from \"@vitejs/plugin-vue\"; export default defineConfig({ plugins: [vue()], // 增加resolve.alias配置 // 此操作后有，项目已经支持了，但是ts依然会飘红，处理方法在下面 resolve: { alias: { \"@\": \"/src\", }, }, }); 2，处理ts飘红：修改项目根目录下的tsconfig.json文件，增加compilerOptions.baseUrl和compilerOptions.paths配置字段 { compilerOptions: { \"baseUrl\": \"./\", \"paths\": { \"@/*\": [\"src/*\"] } } } "},"vite/0.0.2.html":{"url":"vite/0.0.2.html","title":"千.0.2 vue2中使用vite","keywords":"","body":"vue2中使用vite (壹)、初始化项目 yarn create vite ? Select a framework: vanilla (这个地方选择原生，选vue的话默认vue3.0) (贰)、安装插件 yarn add vite-plugin-vue2 -D (叁)、创建配置文件：vite.config.js import { createVuePlugin } from 'vite-plugin-vue2' export default { plugins: [createVuePlugin()] } (肆)、安装vue(需指定版本) && vue-template-compiler yarn add vue@2.6.14 vue-template-compiler (伍)、修改目录 && 文件 1，根目录新建src文件夹，并把根目录下的main.js文件移到src目录下，main.js的内容如下 import Vue from 'vue' import App from './App.vue' new Vue({ render: h => h(App) }).$mount('#app') 2，src目录下创建App.vue文件，App.vue的内容如下： Hello Vite Vue2 3，index.html文件中引入的main.js路径变为如下： (陸)、启动项目 yarn dev (柒)、集成vue-router路由(需指定3.x.x版本) 1，安装vue-router yarn add vue-router@3.5.3 2，创建路由文件(src/router/router.js)，并配置路由信息 // src/router/router.js import Vue from 'vue' import Router from \"vue-router\"; Vue.use(Router) const routes = [ { path: \"/login\", name: \"login\", component: () => import(\"../pages/login.vue\"), }, { path: \"/list\", name: \"list\", component: () => import(\"../pages/list.vue\"), }, ] const router = new Router({ mode: 'history', routes }); export default router; 3，main.js文件内容修改如下 import Vue from 'vue' import router from './router/router.js' import App from './App.vue' new Vue({ router, render: h => h(App) }).$mount('#app') (捌)、集成vuex(需指定版本)状态管理 1，安装vuex，版本为3.x.x yarn add vuex@3.6.2 2，创建store.js文件(src/store/store.js)，并配置相关内容 import Vue from \"vue\"; import Vuex from \"vuex\"; Vue.use(Vuex); export default new Vuex.Store({ state: { count: 0, }, //同步方法 mutations: { SET_COUNT(state) { state.count += 1 }, }, }); 3，main.js文件内容修改如下 import Vue from 'vue' import router from './router/router.js' import store from './store/store.js' import App from './App.vue' new Vue({ store, router, render: h => h(App) }).$mount('#app') (玖)、集成axios发送请求 1，安装axios yarn add axios 2，配置，修改main.js如下： import Vue from 'vue' import router from './router/router.js' import store from './store/store.js' import axios from 'axios' import App from './App.vue' Vue.prototype.$axios = axios new Vue({ store, router, render: h => h(App) }).$mount('#app') 3，使用 export default { methods: { async getList() { const res = await this.$axios.get(\"/mock/getList.json\"); console.log(res.data.data); } } } (拾)、sass支持 Vite 也同时提供了对 .scss, .sass, .less, .styl 和 .stylus 文件的内置支持，只需安装相应的预处理器依赖 文档：https://cn.vitejs.dev/guide/features.html#css-pre-processors yarn add sass -D "},"senior/0.0.0.html":{"url":"senior/0.0.0.html","title":"亿.0.0 数据响应式原理","keywords":"","body":"数据响应式原理 "},"senior/0.0.1.html":{"url":"senior/0.0.1.html","title":"亿.0.1 双向数据绑定原理","keywords":"","body":"双向数据绑定原理 "},"senior/0.0.2.html":{"url":"senior/0.0.2.html","title":"亿.0.2 MVVM原理","keywords":"","body":"MVVM原理 "},"senior/0.0.3.html":{"url":"senior/0.0.3.html","title":"亿.0.3 实现虚拟DOM","keywords":"","body":"实现虚拟DOM 最近一两年前端最火的技术莫过于ReactJS，即便你没用过也该听过，ReactJS由业界顶尖的互联网公司facebook提出，其本身有很多先进的设计思路，比如页面UI组件化、虚拟DOM等。本文将带你解开虚拟DOM的神秘面纱，不仅要理解其原理，而且要实现一个基本可用的虚拟DOM。 1.为什么需要虚拟DOM DOM是很慢的，其元素非常庞大，页面的性能问题鲜有由JS引起的，大部分都是由DOM操作引起的。如果对前端工作进行抽象的话，主要就是维护状态和更新视图；而更新视图和维护状态都需要DOM操作。其实近年来，前端的框架主要发展方向就是解放DOM操作的复杂性。 在jQuery出现以前，我们直接操作DOM结构，这种方法复杂度高，兼容性也较差；有了jQuery强大的选择器以及高度封装的API，我们可以更方便的操作DOM，jQuery帮我们处理兼容性问题，同时也使DOM操作变得简单；但是聪明的程序员不可能满足于此，各种MVVM框架应运而生，有angularJS、avalon、vue.js等，MVVM使用数据双向绑定，使得我们完全不需要操作DOM了，更新了状态视图会自动更新，更新了视图数据状态也会自动更新，可以说MMVM使得前端的开发效率大幅提升，但是其大量的事件绑定使得其在复杂场景下的执行性能堪忧；有没有一种兼顾开发效率和执行效率的方案呢？ReactJS就是一种不错的方案，虽然其将JS代码和HTML代码混合在一起的设计有不少争议，但是其引入的Virtual DOM(虚拟DOM)却是得到大家的一致认同的。 2.理解虚拟DOM 虚拟的DOM的核心思想是：对复杂的文档DOM结构，提供一种方便的工具，进行最小化地DOM操作。这句话，也许过于抽象，却基本概况了虚拟DOM的设计思想 (1) 提供一种方便的工具，使得开发效率得到保证 (2) 保证最小化的DOM操作，使得执行效率得到保证 (1).用JS表示DOM结构 DOM很慢，而javascript很快，用javascript对象可以很容易地表示DOM节点。DOM节点包括标签、属性和子节点，通过VElement表示如下。 //虚拟dom，参数分别为标签名、属性对象、子DOM列表 var VElement = function(tagName, props, children) { //保证只能通过如下方式调用：new VElement if (!(this instanceof VElement)) { return new VElement(tagName, props, children); } //可以通过只传递tagName和children参数 if (util.isArray(props)) { children = props; props = {}; } //设置虚拟dom的相关属性 this.tagName = tagName; this.props = props || {}; this.children = children || []; this.key = props ? props.key : void 666; var count = 0; util.each(this.children, function(child, i) { if (child instanceof VElement) { count += child.count; } else { children[i] = '' + child; } count++; }); this.count = count; } 通过VElement，我们可以很简单地用javascript表示DOM结构。比如 var vdom = velement('div', { 'id': 'container' }, [ velement('h1', { style: 'color:red' }, ['simple virtual dom']), velement('p', ['hello world']), velement('ul', [velement('li', ['item #1']), velement('li', ['item #2'])]), ]); 上面的javascript代码可以表示如下DOM结构： simple virtual dom hello world item #1 item #2 同样我们可以很方便地根据虚拟DOM树构建出真实的DOM树。具体思路：根据虚拟DOM节点的属性和子节点递归地构建出真实的DOM树。见如下代码： VElement.prototype.render = function() { //创建标签 var el = document.createElement(this.tagName); //设置标签的属性 var props = this.props; for (var propName in props) { var propValue = props[propName] util.setAttr(el, propName, propValue); } //依次创建子节点的标签 util.each(this.children, function(child) { //如果子节点仍然为velement，则递归的创建子节点，否则直接创建文本类型节点 var childEl = (child instanceof VElement) ? child.render() : document.createTextNode(child); el.appendChild(childEl); }); return el; } 对一个虚拟的DOM对象VElement，调用其原型的render方法，就可以产生一颗真实的DOM树。 vdom.render(); 既然我们可以用JS对象表示DOM结构，那么当数据状态发生变化而需要改变DOM结构时，我们先通过JS对象表示的虚拟DOM计算出实际DOM需要做的最小变动，然后再操作实际DOM，从而避免了粗放式的DOM操作带来的性能问题。 (2).比较两棵虚拟DOM树的差异 在用JS对象表示DOM结构后，当页面状态发生变化而需要操作DOM时，我们可以先通过虚拟DOM计算出对真实DOM的最小修改量，然后再修改真实DOM结构(因为真实DOM的操作代价太大)。 如下图所示，两个虚拟DOM之间的差异已经标红： 为了便于说明问题，我当然选取了最简单的DOM结构，两个简单DOM之间的差异似乎是显而易见的，但是真实场景下的DOM结构很复杂，我们必须借助于一个有效的DOM树比较算法。 设计一个diff算法有两个要点： 如何比较两个两棵DOM树 如何记录节点之间的差异 如何比较两个两棵DOM树 计算两棵树之间差异的常规算法复杂度为O(n3)，一个文档的DOM结构有上百个节点是很正常的情况，这种复杂度无法应用于实际项目。针对前端的具体情况：我们很少跨级别的修改DOM节点，通常是修改节点的属性、调整子节点的顺序、添加子节点等。因此，我们只需要对同级别节点进行比较，避免了diff算法的复杂性。对同级别节点进行比较的常用方法是深度优先遍历： function diff(oldTree, newTree) { //节点的遍历顺序 var index = 0; //在遍历过程中记录节点的差异 var patches = {}; //深度优先遍历两棵树 dfsWalk(oldTree, newTree, index, patches); return patches; } 如何记录节点之间的差异 由于我们对DOM树采取的是同级比较，因此节点之间的差异可以归结为4种类型： 修改节点属性, 用PROPS表示 修改节点文本内容, 用TEXT表示 替换原有节点, 用REPLACE表示 调整子节点，包括移动、删除等，用REORDER表示 对于节点之间的差异，我们可以很方便地使用上述四种方式进行记录，比如当旧节点被替换时： {type:REPLACE,node:newNode} 而当旧节点的属性被修改时： {type:PROPS,props: newProps} 在深度优先遍历的过程中，每个节点都有一个编号，如果对应的节点有变化，只需要把相应变化的类别记录下来即可。下面是具体实现： function dfsWalk(oldNode, newNode, index, patches) { var currentPatch = []; if (newNode === null) { //依赖listdiff算法进行标记为删除 } else if (util.isString(oldNode) && util.isString(newNode)) { if (oldNode !== newNode) { //如果是文本节点则直接替换文本 currentPatch.push({ type: patch.TEXT, content: newNode }); } } else if (oldNode.tagName === newNode.tagName && oldNode.key === newNode.key) { //节点类型相同 //比较节点的属性是否相同 var propsPatches = diffProps(oldNode, newNode); if (propsPatches) { currentPatch.push({ type: patch.PROPS, props: propsPatches }); } //比较子节点是否相同 diffChildren(oldNode.children, newNode.children, index, patches, currentPatch); } else { //节点的类型不同，直接替换 currentPatch.push({ type: patch.REPLACE, node: newNode }); } if (currentPatch.length) { patches[index] = currentPatch; } } 比如对上文图中的两颗虚拟DOM树，可以用如下数据结构记录它们之间的变化： var patches = { 1:{type:REPLACE,node:newNode}, //h1节点变成h5 5:{type:REORDER,moves:changObj} //ul新增了子节点li } (3).对真实DOM进行最小化修改 通过虚拟DOM计算出两颗真实DOM树之间的差异后，我们就可以修改真实的DOM结构了。上文深度优先遍历过程产生了用于记录两棵树之间差异的数据结构patches, 通过使用patches我们可以方便对真实DOM做最小化的修改。 //将差异应用到真实DOM function applyPatches(node, currentPatches) { util.each(currentPatches, function(currentPatch) { switch (currentPatch.type) { //当修改类型为REPLACE时 case REPLACE: var newNode = (typeof currentPatch.node === 'String') ? document.createTextNode(currentPatch.node) : currentPatch.node.render(); node.parentNode.replaceChild(newNode, node); break; //当修改类型为REORDER时 case REORDER: reoderChildren(node, currentPatch.moves); break; //当修改类型为PROPS时 case PROPS: setProps(node, currentPatch.props); break; //当修改类型为TEXT时 case TEXT: if (node.textContent) { node.textContent = currentPatch.content; } else { node.nodeValue = currentPatch.content; } break; default: throw new Error('Unknow patch type ' + currentPatch.type); } }); } 至此，虚拟DOM的基本原理已经基本讲解完成了；我们也一起实现了一个基本可用的虚拟DOM。 "}}